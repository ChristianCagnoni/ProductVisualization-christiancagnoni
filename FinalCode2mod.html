<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Medieval Weapon</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link href="common.css" rel="stylesheet" type="text/css" />
	</head>
	<body>
		<div class="padding">
            
        </div>
        
        <div class="log">
            <a class="navbar-brand" href="#">
                <img class="center" src="logo.png">
            </a>
        </div>

		<div class="container-fluid">
			<div class="row-padding">
					<header class="container-fluid-padding">
						<h1>
							<b>The Medieval Weapon</b>
						</h1>
						<h5>
							Visualize different types of medieval weapon
						<h5>
                    </header>
                    <div id="controls-container" class="content-column">
                        <label>
                            Products:
                            <select id="products" onchange="changeProd(value)">
                                <option selected value="axe">Axe</option>
                                <option value="shield">Shield</option>
                                <option value="sword">Sword</option>
                                <option value="sickle">Sickle</option>
                            </select>
                        </label>
                        <label>Localized GodRays:<input id="localGodrays" onchange="changeGodRays()" type="checkbox"></label>
                        <label>Global GodRays:<input id="globalGodrays" onchange="changeGodRaysGlob()" type="checkbox"></label>
                        <label>Blurred:<input id="blurred" onchange="changeBlurred()" type="checkbox"></label>
                        <label>Film Grain:<input id="film" onchange="changeFilm()" type="checkbox"></label>
                        <label>Remove Reflections:<input id="iem" onchange="changeIem()" type="checkbox"></label>
                        <label>Cinema Light:<input id="aces" onchange="chnageToneMap()" type="checkbox"></label>
                        <label>Light Intensity:<input id="lighIntensity" onchange="changeIntensity(value)" type="range" min="0.1" max="10.0" step="0.1"></label>
                        <label>
                            Background:
                            <select id="background" onchange="changeBack(value)">
                                <option value="chineseGarden">Chinese Garden</option>
                                <option value="external">External</option>
                                <option value="internal">Internal</option>
                                <option selected value="nightMeadow">Night Meadow</option>
                                <option value="nightPark">Night Park</option>
                                <option value="studio">Studio</option>
                            </select>
                        </label>
                    </div>
					<div id="product" class="row padding">
                        <canvas id="productCanvas" style="padding-bottom: 15px; padding-left: 15px; float: left; display: block;">                            
                        </canvas>
                        <div class="container-fluid" style="padding-bottom: 110.5px; padding-top:0px;padding-right: 42.5%; float: right; display: block">
                            <div class="row-padding">
                                <header class="container-fluid-padding right-half">
                                    <h5 id="name-one">
                                        Handle Material
                                    <h5>
                                    <select id="material1" onchange="changeM1(value)">
                                        <option selected value="metalAxe">Metal one</option>
                                        <option value="goldAxe">Gold</option>
                                        <option value="woodAxe">Wood</option>
                                        <option value="blueShield">Metal Blue</option>
                                        <option value="greenShield">Metal Green</option>
                                        <option value="redShield">Metal Red</option>
                                        <option value="goldSword">Gold Two</option>
                                        <option value="silverSword">Silver</option>
                                        <option value="redSword">Fabric Red</option>
                                        <option value="goldCasual">Modified Gold</option>
                                        <option id="glass" value="glass">Glass</option>
                                        <option id="glow" value="glow">Glow</option>
                                    </select>
                                    <h5 id="name-two">
                                        Blade Material
                                    <h5>
                                    <select id="material2" onchange="changeM2(value)">
                                        <option value="metalAxe">Metal one</option>
                                        <option selected value="goldAxe">Gold</option>
                                        <option value="woodAxe">Wood</option>
                                        <option value="blueShield">Metal Blue</option>
                                        <option value="greenShield">Metal Green</option>
                                        <option value="redShield">Metal Red</option>
                                        <option value="goldSword">Gold Two</option>
                                        <option value="silverSword">Silver</option>
                                        <option value="redSword">Fabric Red</option>
                                        <option value="goldCasual">Modified Gold</option>
                                        <option id="glass1" value="glass">Glass</option>
                                        <option id="glow1" value="glow">Glow</option>
                                    </select>
                                    <h5 id="name-three">
                                        Wedge Material
                                    <h5>
                                    <select id="material3" onchange="changeM3(value)">
                                        <option value="metalAxe">Metal one</option>
                                        <option value="goldAxe">Gold</option>
                                        <option selected value="woodAxe">Wood</option>
                                        <option value="blueShield">Metal Blue</option>
                                        <option value="greenShield">Metal Green</option>
                                        <option value="redShield">Metal Red</option>
                                        <option value="goldSword">Gold Two</option>
                                        <option value="silverSword">Silver</option>
                                        <option value="redSword">Fabric Red</option>
                                        <option value="goldCasual">Modified Gold</option>
                                        <option id="glass2" value="glass">Glass</option>
                                        <option id="glow2" value="glow">Glow</option>
                                    </select>
                                    <h5 id="name-four">
                                        
                                    <h5>
                                    <select id="material4" hidden=true onchange="changeM4(value)">
                                        <option value="metalAxe">Metal one</option>
                                        <option selected value="goldAxe">Gold</option>
                                        <option value="woodAxe">Wood</option>
                                        <option value="blueShield">Metal Blue</option>
                                        <option value="greenShield">Metal Green</option>
                                        <option value="redShield">Metal Red</option>
                                        <option value="goldSword">Gold Two</option>
                                        <option value="silverSword">Silver</option>
                                        <option value="redSword">Fabric Red</option>
                                        <option value="goldCasual">Modified Gold</option>
                                        <option id="glass3" value="glass">Glass</option>
                                        <option id="glow3" value="glow">Glow</option>
                                    </select>
                                    <h5 id="name-five">
                                        
                                    <h5>
                                    <select id="material5" hidden=true onchange="changeM5(value)">
                                        <option value="metalAxe">Metal one</option>
                                        <option value="goldAxe">Gold</option>
                                        <option selected value="woodAxe">Wood</option>
                                        <option value="blueShield">Metal Blue</option>
                                        <option value="greenShield">Metal Green</option>
                                        <option value="redShield">Metal Red</option>
                                        <option value="goldSword">Gold Two</option>
                                        <option value="silverSword">Silver</option>
                                        <option value="redSword">Fabric Red</option>
                                        <option value="goldCasual">Modified Gold</option>
                                        <option id="glass4" value="glass">Glass</option>
                                        <option id="glow4" value="glow">Glow</option>
                                    </select>
                                    <h5>
                                        Animated Material
                                    </h5>
                                    <input id="animated" onchange="changeAnim()" type="checkbox">
                                </header>
                            </div>
                        </div>
                        <div id="gui-container"></div>
                    </div>
		<script src="libs/three.js"></script>
		<script src="libs/stats.min.js"></script>
		<script src="libs/OrbitControls.js"></script>
		<script src='libs/GLTFLoader.js'></script>
        <script src='libs/BufferGeometryUtils.js'></script>
        <script src='libs/Object3d.js'></script>
        <script src='libs/postprocessing.min.js'></script>
        <script src="libs/EffectComposer.js"></script>
        <script src="libs/CopyShader.js"></script>
        <script src="libs/ShaderPass.js"></script>
        <script src="libs/RenderPass.js"></script>
        <script src="libs/GammaCorrectionShader.js"></script>

        <script>
            /*
            funzione che verifica se l'animazione è attivata oppure no, aggiornando gli uniforms
            */
            function changeAnim(){
                var anim=document.getElementById("animated");
                if(anim.checked==true){
                    uniforms1.animEn.value=2.5;
                    uniforms2.animEn.value=2.5;
                    uniforms3.animEn.value=2.5;
                    uniforms4.animEn.value=2.5;
                    uniforms5.animEn.value=2.5;
                }else{
                    uniforms1.animEn.value=0.0;
                    uniforms2.animEn.value=0.0;
                    uniforms3.animEn.value=0.0;
                    uniforms4.animEn.value=0.0;
                    uniforms5.animEn.value=0.0;
                }
            }

            function chnageToneMap(){
                var aces=document.getElementById("aces");
                if(aces.checked==true){
                    aces_TM=new THREE.ShaderPass( toneMap_ACES );
                    composer.addPass(aces_TM);
                    aces_TM.renderToScreen=true;
                }else{
                    composer.removePass(aces_TM);
                }
            }

            /*
            funzione che gestisce l'effetto film della grana, se attivo viene aggiunto come 
            passata del composer
            */
            function changeFilm(){
                var film=document.getElementById("film");
                var x = document.getElementById("globalGodrays");
                var y = document.getElementById("localGodrays");
                var z = document.getElementById("blurred");
                var aces=document.getElementById("aces");
                if(aces.checked==true){
                    composer.removePass(aces_TM);
                    aces.checked=false;
                }
                if(film.checked==true){
                    x.checked=false;
                    changeGodRaysGlob();
                    y.checked=false;
                    changeGodRays();
                    z.checked=false;
                    changeBlurred();
                    filmpass=new THREE.ShaderPass(FilmGrain);
                    composer.addPass(filmpass);
                    filmpass.renderToScreen=true;
                }else{
                    composer = new THREE.EffectComposer( renderer );
			        composer.addPass( new THREE.RenderPass( scene, camera ) );

                    composer.addPass(fxaa);
                    fxaa.renderToScreen=true;
                }
            }

            /*
            funzione che gestisce la pre filtrata EM con BRDF diffusiva
            se attiva aggiorna i materiali delle mesh, disattivando 
            il materiale glow e glass
            */
            function changeIem(){
                var iem=document.getElementById("iem");
                var prod=document.getElementById("products").value;
                var aces=document.getElementById("aces");
                if(aces.checked==true){
                    composer.removePass(aces_TM);
                    aces.checked=false;
                }
                if(iem.checked==true){
                    document.getElementById("glass").disabled=true;
                    document.getElementById("glow").disabled=true;
                    document.getElementById("glass1").disabled=true;
                    document.getElementById("glow1").disabled=true;
                    document.getElementById("glass2").disabled=true;
                    document.getElementById("glow2").disabled=true;
                    document.getElementById("glass3").disabled=true;
                    document.getElementById("glow3").disabled=true;
                    document.getElementById("glass4").disabled=true;
                    document.getElementById("glow4").disabled=true;
                    emMesh.material=altMaterial[0];
                    emMesh1.material=altMaterial[1];
                    emMesh2.material=altMaterial[2];
                    if(prod=="sickle"){
                        emMesh3.material=altMaterial[3];
                        emMesh4.material=altMaterial[4];
                    }
                }else{
                    document.getElementById("glass").disabled=false;
                    document.getElementById("glow").disabled=false;
                    document.getElementById("glass1").disabled=false;
                    document.getElementById("glow1").disabled=false;
                    document.getElementById("glass2").disabled=false;
                    document.getElementById("glow2").disabled=false;
                    document.getElementById("glass3").disabled=false;
                    document.getElementById("glow3").disabled=false;
                    document.getElementById("glass4").disabled=false;
                    document.getElementById("glow4").disabled=false;
                    emMesh.material=ourMaterial[0];
                    emMesh1.material=ourMaterial[1];
                    emMesh2.material=ourMaterial[2];
                    if(prod=="sickle"){
                        emMesh3.material=ourMaterial[3];
                        emMesh4.material=ourMaterial[4];
                    }
                }
            }

            /*
            funzione che si occupa della gestione del prodotto da visualizzare
            ogni volta che si cambia prodotto viene craicato e vengono
            aggiornate le voci della grafica presente
            */
            function changeProd(x){
                var mat1 = document.getElementById("material1");
                var mat2 = document.getElementById("material2");
                var mat3 = document.getElementById("material3");
                var mat4 = document.getElementById("material4");
                var mat5 = document.getElementById("material5");
                var nameo= document.getElementById("name-one");
                var namet= document.getElementById("name-two");
                var nameth= document.getElementById("name-three");
                var namef= document.getElementById("name-four");
                var namefi= document.getElementById("name-five");
                var text1=document.getElementById("text1");
                var text2=document.getElementById("text2");
                var text3=document.getElementById("text3");
                var text4=document.getElementById("text4");
                var price=document.getElementById("price");
                var anim=document.getElementById("animated");
                var iem=document.getElementById("iem");
                iem.checked=false;
                var aces=document.getElementById("aces");
                if(aces.checked==true){
                    composer.removePass(aces_TM);
                    aces.checked=false;
                }

                if(copyMesh!=undefined && mat1!="glow"){
                        scene.remove(copyMesh);
                        copyMesh=undefined;
                    }
                if(copyMesh1!=undefined && mat2!="glow"){
                    scene.remove(copyMesh1);
                    copyMesh1=undefined;
                }
                if(copyMesh2!=undefined && mat3!="glow"){
                    scene.remove(copyMesh2);
                    copyMesh2=undefined;
                }
                if(copyMesh3!=undefined && mat4!="glow"){
                    scene.remove(copyMesh3);
                    copyMesh3=undefined;
                }
                if(copyMesh4!=undefined && mat5!="glow"){
                    scene.remove(copyMesh4);
                    copyMesh4=undefined;
                }

                
                if(x=="axe"){
                    anim.disabled=false;
                    for(var i=0;i<objects.length;i++){
                            scene.remove(objects[i]);
                            obj.remove(objects[i]);
                        }
                        loadAxes();
                        uniforms1.normalMap.value=loadTexture( "textures/texture_axes/Metal032_2K_Normal.jpg" );
                        uniforms1.roughnessMap.value=loadTexture( "textures/texture_axes/Metal032_2K_Roughness.jpg" );
                        uniforms1.specularMap.value=loadTexture( "textures/texture_axes/Metal032_2K_Displacement.jpg" );
                        uniforms1.metalnessMap.value=loadTexture( "textures/texture_axes/Metal032_2K_Metalness.jpg" );
                        uniforms1.diffuseMap.value=loadTexture( "textures/texture_axes/Metal032_2K_Color.jpg" );
                        uniforms2.normalMap.value=loadTexture( "textures/texture_axes/Metal034_2K_Normal.jpg" );
                        uniforms2.roughnessMap.value=loadTexture( "textures/texture_axes/Metal034_2K_Roughness.jpg" );
                        uniforms2.specularMap.value=loadTexture( "textures/texture_axes/Metal034_2K_Displacement.jpg" );
                        uniforms2.metalnessMap.value=loadTexture( "textures/texture_axes/Metal034_2K_Metalness.jpg" );
                        uniforms2.diffuseMap.value=loadTexture( "textures/texture_axes/Metal034_2K_Color.jpg" );
                        uniforms3.normalMap.value=loadTexture( "textures/texture_axes/WoodSiding009_2K_Normal.jpg" );
                        uniforms3.roughnessMap.value=loadTexture( "textures/texture_axes/WoodSiding009_2K_Roughness.jpg" );
                        uniforms3.specularMap.value=loadTexture( "textures/texture_axes/WoodSiding009_2K_Displacement.jpg" );
                        uniforms3.metalnessMap.value=loadTexture( "textures/texture_axes/WoodSiding009_2K_Metalness.jpg" );
                        uniforms3.diffuseMap.value=loadTexture( "textures/texture_axes/WoodSiding009_2K_Color.jpg" );
                        uniforms1.AOMap.value = loadTexture( "textures/texture_axes/Metal032_2K_AO.jpg" );
                        uniforms2.AOMap.value = loadTexture( "textures/texture_axes/Metal034_2K_AO.jpg" );
			            uniforms3.AOMap.value = loadTexture( "textures/texture_axes/WoodSiding009_2K_AO.jpg" );
                        mat1.value="metalAxe";
                        mat2.value="goldAxe";
                        mat3.value="woodAxe";
                        mat4.hidden=true;
                        mat5.hidden=true;
                        nameo.textContent="Handle Material";
                        namet.textContent="Blade Material";
                        nameth.textContent="Wedge Material";
                        namef.textContent="";
                        namefi.textContent="";
                        text1.textContent="to the ax, designed to cut down trees, the battle ax, designed to hit the opponent's arms or legs, has a lighter and more curved metal head.";
                        text2.textContent="weapon, depending on its size, could be wielded with one or two hands and was intended either to guarantee the possibility of fast and repeated attacks or powerful attacks, aimed at knocking down or weakening the opponent.";
                        text3.textContent="The battle axes with a half-moon metal head, widespread in Europe during the Roman period, were usually made of wrought iron with a carbon steel edge or, typical of medieval axes, of pure steel.";
                        text4.textContent="The wooden handle was reinforced with metal strips to ensure greater solidity in the event of an attack carried by the opponent under the ax head. Some models from the Renaissance period feature entirely metal handles.";
                        price.textContent="50$"
                }else if(x=="shield"){
                    anim.disabled=false;
                    for(var i=0;i<objects.length;i++){
                            scene.remove(objects[i]);
                            obj.remove(objects[i]);
                        }
                        loadShield();
                        uniforms1.normalMap.value=loadTexture( "textures/texture_shield/PaintedMetal003_2K_Normal.jpg");
                        uniforms1.roughnessMap.value=loadTexture( "textures/texture_shield/PaintedMetal003_2K_Roughness.jpg" );
                        uniforms1.specularMap.value=loadTexture( "textures/texture_shield/PaintedMetal003_2K_Displacement.jpg" );
                        uniforms1.metalnessMap.value=loadTexture( "textures/texture_shield/PaintedMetal003_2K_Metalness.jpg" );
                        uniforms1.diffuseMap.value=loadTexture( "textures/texture_shield/PaintedMetal003_2K_Color.jpg" );
                        uniforms2.normalMap.value=loadTexture( "textures/texture_shield/PaintedMetal004_2K_Normal.jpg");
                        uniforms2.roughnessMap.value=loadTexture( "textures/texture_shield/PaintedMetal004_2K_Roughness.jpg" );
                        uniforms2.specularMap.value=loadTexture( "textures/texture_shield/PaintedMetal004_2K_Displacement.jpg" );
                        uniforms2.metalnessMap.value=loadTexture( "textures/texture_shield/PaintedMetal004_2K_Metalness.jpg" );
                        uniforms2.diffuseMap.value=loadTexture( "textures/texture_shield/PaintedMetal004_2K_Color.jpg" );
                        uniforms3.normalMap.value=loadTexture( "textures/texture_shield/PaintedMetal005_2K_Normal.jpg");
                        uniforms3.roughnessMap.value=loadTexture( "textures/texture_shield/PaintedMetal005_2K_Roughness.jpg" );
                        uniforms3.specularMap.value=loadTexture( "textures/texture_shield/PaintedMetal005_2K_Displacement.jpg" );
                        uniforms3.metalnessMap.value=loadTexture( "textures/texture_shield/PaintedMetal005_2K_Metalness.jpg" );
                        uniforms3.diffuseMap.value=loadTexture( "textures/texture_shield/PaintedMetal005_2K_Color.jpg" );
                        uniforms1.AOMap.value = loadTexture( "textures/texture_shield/PaintedMetal003_2K_AO.jpg" );
                        uniforms2.AOMap.value = loadTexture( "textures/texture_shield/PaintedMetal004_2K_AO.jpg" );
			            uniforms3.AOMap.value = loadTexture( "textures/texture_shield/PaintedMetal005_2K_AO.jpg" );
                        mat1.value="blueShield";
                        mat2.value="redShield";
                        mat3.value="greenShield";
                        mat4.hidden=true;
                        mat5.hidden=true;
                        nameo.textContent="Handle Material";
                        namet.textContent="Front Material";
                        nameth.textContent="Back Material";
                        namef.textContent="";
                        namefi.textContent="";
                        text1.textContent="The shield is a white weapon dedicated to the active protection of the bearer, that is, voluntarily used to parry, in support of other possible defensive measures (armor, helmet, etc.)";
                        text2.textContent="It consists of a plate of different shapes and materials braced to actively defend against the blows of the opponents.";
                        text3.textContent="Although some primitive populations still use it, it has not been used in warfare since the introduction of firearms, capable of piercing any shield a man could carry during battle, with the only isolated case of the small and heavy targe. ";
                        text4.textContent="Scottish in the 18th century, partially effective against the weapons of the time.";
                        price.textContent="39$"
                    }else if(x=='sword'){
                        anim.disabled=false;
                        for(var i=0;i<objects.length;i++){
                            scene.remove(objects[i]);
                            obj.remove(objects[i]);
                        }
                        loadSword();
                        uniforms1.normalMap.value=loadTexture( "textures/texture_sword/Metal007_2K_Normal.jpg" );
                        uniforms1.roughnessMap.value=loadTexture( "textures/texture_sword/Metal007_2K_Roughness.jpg" );
                        uniforms1.specularMap.value=loadTexture( "textures/texture_sword/Metal007_2K_Displacement.jpg" );
                        uniforms1.metalnessMap.value=loadTexture( "textures/texture_sword/Metal007_2K_Metalness.jpg" );
                        uniforms1.diffuseMap.value=loadTexture( "textures/texture_sword/Metal007_2K_Color.jpg" );
                        uniforms2.normalMap.value=loadTexture( "textures/texture_sword/Metal005_2K_Normal.jpg" );
                        uniforms2.roughnessMap.value=loadTexture( "textures/texture_sword/Metal005_2K_Roughness.jpg" );
                        uniforms2.specularMap.value=loadTexture( "textures/texture_sword/Metal005_2K_Displacement.jpg" );
                        uniforms2.metalnessMap.value=loadTexture( "textures/texture_sword/Metal005_2K_Metalness.jpg" );
                        uniforms2.diffuseMap.value=loadTexture( "textures/texture_sword/Metal005_2K_Color.jpg" );
                        uniforms3.normalMap.value=loadTexture( "textures/texture_sword/Fabric026_2K_Normal.jpg" );
                        uniforms3.roughnessMap.value=loadTexture( "textures/texture_sword/Fabric026_2K_Roughness.jpg" );
                        uniforms3.specularMap.value=loadTexture( "textures/texture_sword/Fabric026_2K_Displacement.jpg" );
                        uniforms3.metalnessMap.value=loadTexture( "textures/texture_sword/Fabric026_2K_Metalness.jpg" );
                        uniforms3.diffuseMap.value=loadTexture( "textures/texture_sword/Fabric026_2K_Color.jpg" );
                        uniforms1.AOMap.value = loadTexture( "textures/texture_sword/Metal007_2K_AO.jpg" );
                        uniforms2.AOMap.value = loadTexture( "textures/texture_sword/Metal005_2K_AO.jpg" );
			            uniforms3.AOMap.value = loadTexture( "textures/texture_sword/Fabric026_2K_AO.jpg" );
                        mat1.value="goldSword";
                        mat2.value="silverSword";
                        mat3.value="redSword";
                        mat4.hidden=true;
                        mat5.hidden=true;
                        nameo.textContent="Blade Material";
                        namet.textContent="Crock Knob Material";
                        nameth.textContent="Hilt Material";
                        namef.textContent="";
                        namefi.textContent="";
                        text1.textContent="A sword is a long-bladed white weapon, often (but not always) double-edged, suitable for striking with the point and cutting edge and used by the most various civilizations in every place of the world and in every era, although mainly in Eurasia and in North Africa.";
                        text2.textContent="It is composed, in its basic structure, of a long blade and the hilt, that is the handle (sleeve) and the guard.";
                        text3.textContent="The intention and the basic physics of the sword have remained substantially unchanged over the centuries but the manufacturing techniques have changed a lot, also varying according to the culture: as a consequence, there are differences in the design and purpose of the blade.";
                        text4.textContent="The fundamental concept behind the weapon is constant, but the techniques of use and the shape itself vary widely across the ages and in the various cultures that use it.";
                        price.textContent="78$"
                    }else{
                        anim.disabled=false;
                        for(var i=0;i<objects.length;i++){
                            scene.remove(objects[i]);
                            obj.remove(objects[i]);
                        }
                        loadSickle();
                        uniforms1.normalMap.value=loadTexture( "textures/texture_sword/Fabric026_2K_Normal.jpg" );
                        uniforms1.roughnessMap.value=loadTexture( "textures/texture_sword/Fabric026_2K_Roughness.jpg" );
                        uniforms1.specularMap.value=loadTexture( "textures/texture_sword/Fabric026_2K_Displacement.jpg" );
                        uniforms1.metalnessMap.value=loadTexture( "textures/texture_sword/Fabric026_2K_Metalness.jpg" );
                        uniforms1.diffuseMap.value=loadTexture( "textures/texture_sword/Fabric026_2K_Color.jpg" );
                        uniforms1.AOMap.value=loadTexture( "textures/texture_sword/Fabric026_2K_AO.jpg" );
                        uniforms2.normalMap.value=loadTexture( "textures/texture_sword/Metal005_2K_Normal.jpg" );
                        uniforms2.roughnessMap.value=loadTexture( "textures/texture_sword/Metal005_2K_Roughness.jpg" );
                        uniforms2.specularMap.value=loadTexture( "textures/texture_sword/Metal005_2K_Displacement.jpg" );
                        uniforms2.metalnessMap.value=loadTexture( "textures/texture_sword/Metal005_2K_Metalness.jpg" );
                        uniforms2.diffuseMap.value=loadTexture( "textures/texture_sword/Metal005_2K_Color.jpg" );
                        uniforms2.AOMap.value=loadTexture( "textures/texture_sword/Metal005_2K_AO.jpg" );
                        uniforms3.normalMap.value=loadTexture( "textures/texture_axes/Metal032_2K_Normal.jpg" );
                        uniforms3.roughnessMap.value=loadTexture( "textures/texture_axes/Metal032_2K_Roughness.jpg" );
                        uniforms3.specularMap.value=loadTexture( "textures/texture_axes/Metal032_2K_Displacement.jpg" );
                        uniforms3.metalnessMap.value=loadTexture( "textures/texture_axes/Metal032_2K_Metalness.jpg" );
                        uniforms3.diffuseMap.value=loadTexture( "textures/texture_axes/Metal032_2K_Color.jpg" );
                        uniforms3.AOMap.value=loadTexture( "textures/texture_axes/Metal032_2K_AO.jpg" );
                        uniforms4.normalMap.value=loadTexture( "textures/texture_sword/Metal007_2K_Normal.jpg" );
                        uniforms4.roughnessMap.value=loadTexture( "textures/texture_sword/Metal007_2K_Roughness.jpg" );
                        uniforms4.specularMap.value=loadTexture( "textures/texture_sword/Metal007_2K_Displacement.jpg" );
                        uniforms4.metalnessMap.value=loadTexture( "textures/texture_sword/Metal007_2K_Metalness.jpg" );
                        uniforms4.diffuseMap.value=loadTexture( "textures/texture_sword/Metal007_2K_Color.jpg" );
                        uniforms4.AOMap.value=loadTexture( "textures/texture_sword/Metal007_2K_AO.jpg" );
                        uniforms5.normalMap.value=loadTexture( "textures/texture_shield/PaintedMetal004_2K_Normal.jpg");
                        uniforms5.roughnessMap.value=loadTexture( "textures/texture_shield/PaintedMetal004_2K_Roughness.jpg" );
                        uniforms5.specularMap.value=loadTexture( "textures/texture_shield/PaintedMetal004_2K_Displacement.jpg" );
                        uniforms5.metalnessMap.value=loadTexture( "textures/texture_shield/PaintedMetal004_2K_Metalness.jpg" );
                        uniforms5.diffuseMap.value=loadTexture( "textures/texture_shield/PaintedMetal004_2K_Color.jpg" );
                        uniforms5.AOMap.value=loadTexture( "textures/texture_shield/PaintedMetal004_2K_AO.jpg" );
                        mat1.value="redSword";
                        mat2.value="silverSword";
                        mat3.value="metalAxe";
                        mat4.hidden=false;
                        mat4.value="goldSword";
                        mat5.hidden=false;
                        mat5.value="redShield";
                        nameo.textContent="Handle Material";
                        namet.textContent="Tube Material";
                        nameth.textContent="Stem Material";
                        namef.textContent="Blade Material";
                        namefi.textContent="Internal Blade Material";
                        text1.textContent="The first people of antiquity to make systematic use of the scythe as a weapon of war were the Thracians.";
                        text2.textContent="The types of curved blade weapons, sharpened on the concave side, developed by this population were many: the real war sickle, the romfaia, a weapon attached to a sickle blade but with a curvature not as marked as the war sickle, and the sica, a kind of war sickle.";
                        text3.textContent="The Persians instead mounted sickle blades on the wheels of their chariots, creating the scythed chariots to try to balance the balance of forces between cavalry and infantry put in crisis by the heavy infantry of the Greeks, the hoplitic phalanx. However, the overwhelming victory of Alexander the Great in the Battle of Gaugamela (331 BC) showed that the age of war chariots had definitively ended.";
                        text4.textContent="A thin sickle blade, sharpened on both the convex and concave sides, gripped in a one-handed wooden hilt was instead the distinctive weapon of the infantry of the Kingdom of Axum (1st century BC-10th century): the shotel.";
                        price.textContent="125$"
                    }
            }
        </script>

        <script>
            /*
            funzione che aggiorna l'intensità della luce
            */
            function changeIntensity(x){
                uniforms1.intensity.value=x;
                uniforms2.intensity.value=x;
                uniforms3.intensity.value=x;
                uniforms4.intensity.value=x;
                uniforms5.intensity.value=x;
            }
        </script>

        <script>
            /*
            funzione che carica il background selezionato
            e aggiorna i vari uniforms
            */
            function changeBack(x){
                if(x=='chineseGarden'){
                        loadEnvMapCG();
                        uniforms1.envMap.value=textureCube;
                        uniforms2.envMap.value=textureCube;
                        uniforms3.envMap.value=textureCube;
                        uniforms4.envMap.value=textureCube;
                        uniforms5.envMap.value=textureCube;
                    }else if(x=='external'){
                        loadEnvMapE();
                        uniforms1.envMap.value=textureCube;
                        uniforms2.envMap.value=textureCube;
                        uniforms3.envMap.value=textureCube;
                        uniforms4.envMap.value=textureCube;
                        uniforms5.envMap.value=textureCube;
                    }else if(x=='internal'){
                        loadEnvMapI();
                        uniforms1.envMap.value=textureCube;
                        uniforms2.envMap.value=textureCube;
                        uniforms3.envMap.value=textureCube;
                        uniforms4.envMap.value=textureCube;
                        uniforms5.envMap.value=textureCube;
                    }else if(x=='nightMeadow'){
                        loadEnvMapNM();
                        uniforms1.envMap.value=textureCube;
                        uniforms2.envMap.value=textureCube;
                        uniforms3.envMap.value=textureCube;
                        uniforms4.envMap.value=textureCube;
                        uniforms5.envMap.value=textureCube;
                    }else if(x=='nightPark'){
                        loadEnvMapNP();
                        uniforms1.envMap.value=textureCube;
                        uniforms2.envMap.value=textureCube;
                        uniforms3.envMap.value=textureCube;
                        uniforms4.envMap.value=textureCube;
                        uniforms5.envMap.value=textureCube;
                    }else {
                        loadEnvMapS();
                        uniforms1.envMap.value=textureCube;
                        uniforms2.envMap.value=textureCube;
                        uniforms3.envMap.value=textureCube;
                        uniforms4.envMap.value=textureCube;
                        uniforms5.envMap.value=textureCube;
                    }
            }
        </script>

        <script>

            /*
            funzione che gestisce l'attivazione dei god rays globali
            definisce gli uniforms da usare e attiva anche un effetto di fxaa
            */
            function changeGodRaysGlob(){
                var x = document.getElementById("globalGodrays");
                var y = document.getElementById("localGodrays");
                var z = document.getElementById("blurred");
                var price=document.getElementById("price");
                var film=document.getElementById("film");
                var pass;
                var aces=document.getElementById("aces");
                if(aces.checked==true){
                    composer.removePass(aces_TM);
                    aces.checked=false;
                }
                if(x.checked==true){
                    y.checked=false;
                    changeGodRays();
                    z.checked=false;
                    changeBlurred();
                    film.checked=false;
                    changeFilm();
                    
                    const screenPosition=new THREE.Vector2();
                    screenPosition.set(
                        Math.min(Math.max((0.0 + 1.0) * 0.5, -1.0), 2.0),
                        Math.min(Math.max((0.0 + 1.0) * 0.5, -1.0), 2.0)
                        );

                    pass = new THREE.ShaderPass( THREE.VolumetericLightShader );
                    pass.needsSwap = true;
                    composer.addPass( pass );

                    pass.uniforms.exposure.value=0.4;
                    pass.uniforms.decay.value=0.95;
                    pass.uniforms.density.value=0.8;
                    pass.uniforms.weight.value=0.15;
                    pass.uniforms.lightPosition.value=screenPosition;
                    
                    volumetericLightShaderUniforms = pass.uniforms;

                    composer.removePass(fxaa);

                    composer.addPass(fxaa);
                    fxaa.renderToScreen=true;

                }else{
                    composer = new THREE.EffectComposer( renderer);
                    composer.addPass( new THREE.RenderPass( scene, camera ) );

                    composer.addPass(fxaa);
                    fxaa.renderToScreen=true;
                }
            }

            /*
            funzione che gestisce l'attivazione dei god rays localizzati
            usa 2 god rays per ogni prodotto
            */
            //1)blurPass->(convolution matrial:
            //https://github.com/vanruesc/postprocessing/blob/main/src/materials/glsl/convolution/shader.vert <- inizilizza i coordinate dei 4 angoli dei vertici e passali al fragment 
            //https://github.com/vanruesc/postprocessing/blob/main/src/materials/glsl/convolution/shader.frag <- accedi ai 4 campioni e fai la media
            //)(kernelSize)
            //2)renderer pass
            //3)depth mask pass->(DepthMaskMaterial: <- inizializza uniforms per gli shaders e fai test sul depth per stabilire dove applicare l'effetto e dove no
            //https://github.com/vanruesc/postprocessing/blob/main/src/materials/glsl/common/shader.vert <- media della posizione sommato a 0.5
            //https://github.com/vanruesc/postprocessing/blob/main/src/materials/glsl/depth-mask/shader.frag) <-in base ai test fatti nel material stabilisce quali parti ricevono l'ffetto god rays mascherando quelle su cui non applicarlo
            //4)godRaysPass->(GodRaysMaterial:<-inizializza i vari uniforms necessari per l'effetto god rays
            //https://github.com/vanruesc/postprocessing/blob/main/src/materials/glsl/common/shader.vert <- media della posizione sommato a 0.5
            //https://github.com/vanruesc/postprocessing/blob/main/src/materials/glsl/god-rays/shader.frag) <- uguale a quello globale presente qui
            function changeGodRays(){
                var x = document.getElementById("localGodrays");
                var y = document.getElementById("globalGodrays");
                var z = document.getElementById("blurred");
                var prod= document.getElementById("products").value;
                var price=document.getElementById("price");
                var film=document.getElementById("film");
                var aces=document.getElementById("aces");
                if(aces.checked==true){
                    composer.removePass(aces_TM);
                    aces.checked=false;
                }
                if(x.checked==true){
                    y.checked=false;
                    changeGodRaysGlob();
                    z.checked=false;
                    changeBlurred();
                    film.checked=false;
                    changeFilm();
                    let godraysEffect = new POSTPROCESSING.GodRaysEffect(camera, emMesh, {
                            resolutionScale: 1,
                            density: 0.8,
                            decay: 0.95,
                            weight: 0.9,
                            samples: 100
                        });
                    let godraysEffect1 = new POSTPROCESSING.GodRaysEffect(camera, emMesh1, {
                            resolutionScale: 1,
                            density: 0.8,
                            decay: 0.95,
                            weight: 0.9,
                            samples: 100
                        });
                    let godraysEffect2 = new POSTPROCESSING.GodRaysEffect(camera, emMesh2, {
                            resolutionScale: 1,
                            density: 0.8,
                            decay: 0.95,
                            weight: 0.9,
                            samples: 100
                        });
                    var godraysEffect3;
                    var godraysEffect4;
                    if(prod=="sickle"){
                            godraysEffect3 = new POSTPROCESSING.GodRaysEffect(camera, emMesh3, {
                            resolutionScale: 1,
                            density: 0.8,
                            decay: 0.95,
                            weight: 0.9,
                            samples: 100
                            });
                        godraysEffect4 = new POSTPROCESSING.GodRaysEffect(camera, emMesh4, {
                            resolutionScale: 1,
                            density: 0.8,
                            decay: 0.95,
                            weight: 0.9,
                            samples: 100
                        }); 
                    }
                    composer = new POSTPROCESSING.EffectComposer(renderer);
                    let renderPass = new POSTPROCESSING.RenderPass(scene, camera);
                    composer.addPass(renderPass);
                    var effectPass;
                    if(prod!="sickle"){
                            effectPass = new POSTPROCESSING.EffectPass(camera,godraysEffect1,godraysEffect2);
                            effectPass.renderToScreen = true;
                            composer.addPass(effectPass);
                            emMesh.material.transparent=false;
                            emMesh.material.depthWrite=true;
                    }else{
                            effectPass = new POSTPROCESSING.EffectPass(camera,godraysEffect,godraysEffect4);
                            effectPass.renderToScreen = true;
                            composer.addPass(effectPass);
                            emMesh1.material.transparent=false;
                            emMesh1.material.depthWrite=true;
                            emMesh2.material.transparent=false;
                            emMesh2.material.depthWrite=true;
                            emMesh3.material.transparent=false;
                            emMesh3.material.depthWrite=true;
                    }
                }else{
                    composer = new THREE.EffectComposer( renderer );
			        composer.addPass( new THREE.RenderPass( scene, camera ) );

                    composer.addPass(fxaa);
                    fxaa.renderToScreen=true;

                    emMesh.material.transparent=false;
                    emMesh.material.depthWrite=true;
                    emMesh1.material.transparent=false;
                    emMesh1.material.depthWrite=true;
                    emMesh2.material.transparent=false;
                    emMesh2.material.depthWrite=true;
                    if(prod=="sickle"){
                        emMesh3.material.transparent=false;
                        emMesh3.material.depthWrite=true;
                        emMesh4.material.transparent=false;
                        emMesh4.material.depthWrite=true;
                    }
                }
            }

            /*
            funzione che gestisce l'attivazione dell'effetto blur
            prima aggiunge il blur verticale e poi quello orizzontale
            */
            function changeBlurred(){
                var x = document.getElementById("blurred");
                var y = document.getElementById("localGodrays");
                var z = document.getElementById("globalGodrays");
                var film=document.getElementById("film");
                var price=document.getElementById("price");
                var aces=document.getElementById("aces");
                if(aces.checked==true){
                    composer.removePass(aces_TM);
                    aces.checked=false;
                }
                if(x.checked==true){
                    y.checked=false;
                    changeGodRays();
                    z.checked=false;
                    changeGodRaysGlob();
                    film.checked=false;
                    changeFilm();

                    blurEffectV = new THREE.ShaderPass( blurShaderV );
                    blurEffectV.uniforms.v.value=2.2/window.innerHeight;
                    composer.addPass( blurEffectV );

                    blurEffectO = new THREE.ShaderPass( blurShaderO );
                    blurEffectO.uniforms.h.value=2.5/window.innerWidth;
                    composer.addPass( blurEffectO );
                    blurEffectO.renderToScreen=true;   
                }else{
                    composer = new THREE.EffectComposer( renderer );
			        composer.addPass( new THREE.RenderPass( scene, camera ) );

                    composer.addPass(fxaa);
                    fxaa.renderToScreen=true;
                }
                
            }
        </script>

        <script>

            /*
            funzione che si occupa di gestire il cambiamento del materiale della prima mesh
            */
            function changeM1(x){
                if(x!='glass' && x!='glow'){
                    if(document.getElementById("iem").checked==true){
                        emMesh.material=altMaterial[0];
                    }else{
                        emMesh.material=ourMaterial[0];
                    }
                }
                if(copyMesh!=undefined && x!="glow"){
                        scene.remove(copyMesh);
                        copyMesh=undefined;
                    }
                if(x=='metalAxe'){
                        uniforms1.normalMap.value=loadTexture( "textures/texture_axes/Metal032_2K_Normal.jpg" );
                        uniforms1.roughnessMap.value=loadTexture( "textures/texture_axes/Metal032_2K_Roughness.jpg" );
                        uniforms1.specularMap.value=loadTexture( "textures/texture_axes/Metal032_2K_Displacement.jpg" );
                        uniforms1.metalnessMap.value=loadTexture( "textures/texture_axes/Metal032_2K_Metalness.jpg" );
                        uniforms1.diffuseMap.value=loadTexture( "textures/texture_axes/Metal032_2K_Color.jpg" );
                        uniforms1.AOMap.value=loadTexture( "textures/texture_axes/Metal032_2K_AO.jpg" );
                    }else if(x=='goldAxe'){
                        uniforms1.normalMap.value=loadTexture( "textures/texture_axes/Metal034_2K_Normal.jpg" );
                        uniforms1.roughnessMap.value=loadTexture( "textures/texture_axes/Metal034_2K_Roughness.jpg" );
                        uniforms1.specularMap.value=loadTexture( "textures/texture_axes/Metal034_2K_Displacement.jpg" );
                        uniforms1.metalnessMap.value=loadTexture( "textures/texture_axes/Metal034_2K_Metalness.jpg" );
                        uniforms1.diffuseMap.value=loadTexture( "textures/texture_axes/Metal034_2K_Color.jpg" );
                        uniforms1.AOMap.value=loadTexture( "textures/texture_axes/Metal034_2K_AO.jpg" );
                    }else if(x=='woodAxe'){
                        uniforms1.normalMap.value=loadTexture( "textures/texture_axes/WoodSiding009_2K_Normal.jpg" );
                        uniforms1.roughnessMap.value=loadTexture( "textures/texture_axes/WoodSiding009_2K_Roughness.jpg" );
                        uniforms1.specularMap.value=loadTexture( "textures/texture_axes/WoodSiding009_2K_Displacement.jpg" );
                        uniforms1.metalnessMap.value=loadTexture( "textures/texture_axes/WoodSiding009_2K_Metalness.jpg" );
                        uniforms1.diffuseMap.value=loadTexture( "textures/texture_axes/WoodSiding009_2K_Color.jpg" );
                        uniforms1.AOMap.value=loadTexture( "textures/texture_axes/WoodSiding009_2K_AO.jpg" );
                    }else if(x=='blueShield'){
                        uniforms1.normalMap.value=loadTexture( "textures/texture_shield/PaintedMetal003_2K_Normal.jpg");
                        uniforms1.roughnessMap.value=loadTexture( "textures/texture_shield/PaintedMetal003_2K_Roughness.jpg" );
                        uniforms1.specularMap.value=loadTexture( "textures/texture_shield/PaintedMetal003_2K_Displacement.jpg" );
                        uniforms1.metalnessMap.value=loadTexture( "textures/texture_shield/PaintedMetal003_2K_Metalness.jpg" );
                        uniforms1.diffuseMap.value=loadTexture( "textures/texture_shield/PaintedMetal003_2K_Color.jpg" );
                        uniforms1.AOMap.value=loadTexture( "textures/texture_shield/PaintedMetal003_2K_AO.jpg" );
                    }else if(x=='redShield'){
                        uniforms1.normalMap.value=loadTexture( "textures/texture_shield/PaintedMetal004_2K_Normal.jpg");
                        uniforms1.roughnessMap.value=loadTexture( "textures/texture_shield/PaintedMetal004_2K_Roughness.jpg" );
                        uniforms1.specularMap.value=loadTexture( "textures/texture_shield/PaintedMetal004_2K_Displacement.jpg" );
                        uniforms1.metalnessMap.value=loadTexture( "textures/texture_shield/PaintedMetal004_2K_Metalness.jpg" );
                        uniforms1.diffuseMap.value=loadTexture( "textures/texture_shield/PaintedMetal004_2K_Color.jpg" );
                        uniforms1.AOMap.value=loadTexture( "textures/texture_shield/PaintedMetal004_2K_AO.jpg" );
                    }else if(x=='greenShield'){
                        uniforms1.normalMap.value=loadTexture( "textures/texture_shield/PaintedMetal005_2K_Normal.jpg");
                        uniforms1.roughnessMap.value=loadTexture( "textures/texture_shield/PaintedMetal005_2K_Roughness.jpg" );
                        uniforms1.specularMap.value=loadTexture( "textures/texture_shield/PaintedMetal005_2K_Displacement.jpg" );
                        uniforms1.metalnessMap.value=loadTexture( "textures/texture_shield/PaintedMetal005_2K_Metalness.jpg" );
                        uniforms1.diffuseMap.value=loadTexture( "textures/texture_shield/PaintedMetal005_2K_Color.jpg" );
                        uniforms1.AOMap.value=loadTexture( "textures/texture_shield/PaintedMetal005_2K_AO.jpg" );
                    }else if(x=='goldSword'){
                        uniforms1.normalMap.value=loadTexture( "textures/texture_sword/Metal007_2K_Normal.jpg" );
                        uniforms1.roughnessMap.value=loadTexture( "textures/texture_sword/Metal007_2K_Roughness.jpg" );
                        uniforms1.specularMap.value=loadTexture( "textures/texture_sword/Metal007_2K_Displacement.jpg" );
                        uniforms1.metalnessMap.value=loadTexture( "textures/texture_sword/Metal007_2K_Metalness.jpg" );
                        uniforms1.diffuseMap.value=loadTexture( "textures/texture_sword/Metal007_2K_Color.jpg" );
                        uniforms1.AOMap.value=loadTexture( "textures/texture_sword/Metal007_2K_AO.jpg" );
                    }else if(x=='silverSword'){
                        uniforms1.normalMap.value=loadTexture( "textures/texture_sword/Metal005_2K_Normal.jpg" );
                        uniforms1.roughnessMap.value=loadTexture( "textures/texture_sword/Metal005_2K_Roughness.jpg" );
                        uniforms1.specularMap.value=loadTexture( "textures/texture_sword/Metal005_2K_Displacement.jpg" );
                        uniforms1.metalnessMap.value=loadTexture( "textures/texture_sword/Metal005_2K_Metalness.jpg" );
                        uniforms1.diffuseMap.value=loadTexture( "textures/texture_sword/Metal005_2K_Color.jpg" );
                        uniforms1.AOMap.value=loadTexture( "textures/texture_sword/Metal005_2K_AO.jpg" );
                    }else if(x=='glass'){
                        emMesh.material=glassMaterial[0];
                    }else if(x=='glow'){
                        emMesh.material=glowMaterial[0];
                        copyMesh=undefined;
                        copyMesh=new THREE.Mesh(emMesh.geometry.clone(),customGlowMaterial);
                        var p =document.getElementById("products").value;
                        if(p!="sickle")copyMesh.scale.multiplyScalar(0.15);
                        scene.add(copyMesh);
                        if(p=="axe"){
                            copyMesh.position.z=emMesh.position.z;
                        }else if(p=="shield"){
                            copyMesh.position.z=emMesh.position.z;
                            copyMesh.position.x=emMesh.position.x;
                        }else if(p=="sword"){
                            copyMesh.position.z=emMesh.position.z;
                            copyMesh.rotation.y=emMesh.rotation.y;
                            copyMesh.position.y+=0.2;
                        }else{
                            copyMesh.position.z=emMesh.position.z;
                            copyMesh.scale.y=5.5;
                            copyMesh.scale.x=0.15;
                            copyMesh.scale.z=0.15;
                        }
                    }else if(x=='goldCasual'){
                        uniforms1.normalMap.value=loadTexture( "textures/prova3.jpg" );
                        uniforms1.roughnessMap.value=loadTexture( "textures/prova6.jpg" );
                        uniforms1.specularMap.value=loadTexture( "textures/prova2.jpg" );
                        uniforms1.metalnessMap.value=loadTexture( "textures/prova4.jpg" );
                        uniforms1.diffuseMap.value=loadTexture( "textures/prova.jpg" );
                        uniforms1.AOMap.value=loadTexture( "textures/prova5.jpg" );
                    }else{
                        uniforms1.normalMap.value=loadTexture( "textures/texture_sword/Fabric026_2K_Normal.jpg" );
                        uniforms1.roughnessMap.value=loadTexture( "textures/texture_sword/Fabric026_2K_Roughness.jpg" );
                        uniforms1.specularMap.value=loadTexture( "textures/texture_sword/Fabric026_2K_Displacement.jpg" );
                        uniforms1.metalnessMap.value=loadTexture( "textures/texture_sword/Fabric026_2K_Metalness.jpg" );
                        uniforms1.diffuseMap.value=loadTexture( "textures/texture_sword/Fabric026_2K_Color.jpg" );
                        uniforms1.AOMap.value=loadTexture( "textures/texture_sword/Fabric026_2K_AO.jpg" );
                    }
            }

            /*
            funzione che si occupa di gestire il cambiamento del materiale della seconda mesh
            */
            function changeM2(x){
                if(x!='glass' && x!='glow'){
                    if(document.getElementById("iem").checked==true){
                        emMesh1.material=altMaterial[1];
                    }else{
                        emMesh1.material=ourMaterial[1];
                    }
                }
                if(copyMesh1!=undefined && x!="glow"){
                        scene.remove(copyMesh1);
                        copyMesh1=undefined;
                    }
                if(x=='metalAxe'){
                        uniforms2.normalMap.value=loadTexture( "textures/texture_axes/Metal032_2K_Normal.jpg" );
                        uniforms2.roughnessMap.value=loadTexture( "textures/texture_axes/Metal032_2K_Roughness.jpg" );
                        uniforms2.specularMap.value=loadTexture( "textures/texture_axes/Metal032_2K_Displacement.jpg" );
                        uniforms2.metalnessMap.value=loadTexture( "textures/texture_axes/Metal032_2K_Metalness.jpg" );
                        uniforms2.diffuseMap.value=loadTexture( "textures/texture_axes/Metal032_2K_Color.jpg" );
                        uniforms2.AOMap.value=loadTexture( "textures/texture_axes/Metal032_2K_AO.jpg" );
                    }else if(x=='goldAxe'){
                        uniforms2.normalMap.value=loadTexture( "textures/texture_axes/Metal034_2K_Normal.jpg" );
                        uniforms2.roughnessMap.value=loadTexture( "textures/texture_axes/Metal034_2K_Roughness.jpg" );
                        uniforms2.specularMap.value=loadTexture( "textures/texture_axes/Metal034_2K_Displacement.jpg" );
                        uniforms2.metalnessMap.value=loadTexture( "textures/texture_axes/Metal034_2K_Metalness.jpg" );
                        uniforms2.diffuseMap.value=loadTexture( "textures/texture_axes/Metal034_2K_Color.jpg" );
                        uniforms2.AOMap.value=loadTexture( "textures/texture_axes/Metal034_2K_AO.jpg" );
                    }else if(x=='woodAxe'){
                        uniforms2.normalMap.value=loadTexture( "textures/texture_axes/WoodSiding009_2K_Normal.jpg" );
                        uniforms2.roughnessMap.value=loadTexture( "textures/texture_axes/WoodSiding009_2K_Roughness.jpg" );
                        uniforms2.specularMap.value=loadTexture( "textures/texture_axes/WoodSiding009_2K_Displacement.jpg" );
                        uniforms2.metalnessMap.value=loadTexture( "textures/texture_axes/WoodSiding009_2K_Metalness.jpg" );
                        uniforms2.diffuseMap.value=loadTexture( "textures/texture_axes/WoodSiding009_2K_Color.jpg" );
                        uniforms2.AOMap.value=loadTexture( "textures/texture_axes/WoodSiding009_2K_AO.jpg" );
                    }else if(x=='blueShield'){
                        uniforms2.normalMap.value=loadTexture( "textures/texture_shield/PaintedMetal003_2K_Normal.jpg");
                        uniforms2.roughnessMap.value=loadTexture( "textures/texture_shield/PaintedMetal003_2K_Roughness.jpg" );
                        uniforms2.specularMap.value=loadTexture( "textures/texture_shield/PaintedMetal003_2K_Displacement.jpg" );
                        uniforms2.metalnessMap.value=loadTexture( "textures/texture_shield/PaintedMetal003_2K_Metalness.jpg" );
                        uniforms2.diffuseMap.value=loadTexture( "textures/texture_shield/PaintedMetal003_2K_Color.jpg" );
                        uniforms2.AOMap.value=loadTexture( "textures/texture_shield/PaintedMetal003_2K_AO.jpg" );
                    }else if(x=='redShield'){
                        uniforms2.normalMap.value=loadTexture( "textures/texture_shield/PaintedMetal004_2K_Normal.jpg");
                        uniforms2.roughnessMap.value=loadTexture( "textures/texture_shield/PaintedMetal004_2K_Roughness.jpg" );
                        uniforms2.specularMap.value=loadTexture( "textures/texture_shield/PaintedMetal004_2K_Displacement.jpg" );
                        uniforms2.metalnessMap.value=loadTexture( "textures/texture_shield/PaintedMetal004_2K_Metalness.jpg" );
                        uniforms2.diffuseMap.value=loadTexture( "textures/texture_shield/PaintedMetal004_2K_Color.jpg" );
                        uniforms2.AOMap.value=loadTexture( "textures/texture_shield/PaintedMetal004_2K_AO.jpg" );
                    }else if(x=='greenShield'){
                        uniforms2.normalMap.value=loadTexture( "textures/texture_shield/PaintedMetal005_2K_Normal.jpg");
                        uniforms2.roughnessMap.value=loadTexture( "textures/texture_shield/PaintedMetal005_2K_Roughness.jpg" );
                        uniforms2.specularMap.value=loadTexture( "textures/texture_shield/PaintedMetal005_2K_Displacement.jpg" );
                        uniforms2.metalnessMap.value=loadTexture( "textures/texture_shield/PaintedMetal005_2K_Metalness.jpg" );
                        uniforms2.diffuseMap.value=loadTexture( "textures/texture_shield/PaintedMetal005_2K_Color.jpg" );
                        uniforms2.AOMap.value=loadTexture( "textures/texture_shield/PaintedMetal005_2K_AO.jpg" );
                    }else if(x=='goldSword'){
                        uniforms2.normalMap.value=loadTexture( "textures/texture_sword/Metal007_2K_Normal.jpg" );
                        uniforms2.roughnessMap.value=loadTexture( "textures/texture_sword/Metal007_2K_Roughness.jpg" );
                        uniforms2.specularMap.value=loadTexture( "textures/texture_sword/Metal007_2K_Displacement.jpg" );
                        uniforms2.metalnessMap.value=loadTexture( "textures/texture_sword/Metal007_2K_Metalness.jpg" );
                        uniforms2.diffuseMap.value=loadTexture( "textures/texture_sword/Metal007_2K_Color.jpg" );
                        uniforms2.AOMap.value=loadTexture( "textures/texture_sword/Metal007_2K_AO.jpg" );
                    }else if(x=='silverSword'){
                        uniforms2.normalMap.value=loadTexture( "textures/texture_sword/Metal005_2K_Normal.jpg" );
                        uniforms2.roughnessMap.value=loadTexture( "textures/texture_sword/Metal005_2K_Roughness.jpg" );
                        uniforms2.specularMap.value=loadTexture( "textures/texture_sword/Metal005_2K_Displacement.jpg" );
                        uniforms2.metalnessMap.value=loadTexture( "textures/texture_sword/Metal005_2K_Metalness.jpg" );
                        uniforms2.diffuseMap.value=loadTexture( "textures/texture_sword/Metal005_2K_Color.jpg" );
                        uniforms2.AOMap.value=loadTexture( "textures/texture_sword/Metal005_2K_AO.jpg" );
                    }else if(x=='glass'){
                        emMesh1.material=glassMaterial[1];
                    }else if(x=='glow'){
                        emMesh1.material=glowMaterial[1];
                        copyMesh1=undefined;
                        copyMesh1=new THREE.Mesh(emMesh1.geometry.clone(),customGlowMaterial);
                        var p =document.getElementById("products").value;
                        if(p!="sickle")copyMesh1.scale.multiplyScalar(0.15);
                        scene.add(copyMesh1);
                        if(p=="axe"){
                            copyMesh1.position.z=emMesh1.position.z;
                        }else if(p=="shield"){
                            copyMesh1.position.z=emMesh1.position.z;
                            copyMesh1.position.x=emMesh1.position.x;
                        }else if(p=="sword"){
                            copyMesh1.rotation.y=emMesh1.rotation.y;
                            copyMesh1.position.y=emMesh1.position.y;
                            copyMesh1.position.y+=0.2;
                        }else{
                            copyMesh1.scale.y=5.5;
                            copyMesh1.scale.x=0.15;
                            copyMesh1.scale.z=0.15;
                        }
                    }else if(x=='goldCasual'){
                        uniforms2.normalMap.value=loadTexture( "textures/prova3.jpg" );
                        uniforms2.roughnessMap.value=loadTexture( "textures/prova6.jpg" );
                        uniforms2.specularMap.value=loadTexture( "textures/prova2.jpg" );
                        uniforms2.metalnessMap.value=loadTexture( "textures/prova4.jpg" );
                        uniforms2.diffuseMap.value=loadTexture( "textures/prova.jpg" );
                        uniforms2.AOMap.value=loadTexture( "textures/prova5.jpg" );
                    }else{
                        uniforms2.normalMap.value=loadTexture( "textures/texture_sword/Fabric026_2K_Normal.jpg" );
                        uniforms2.roughnessMap.value=loadTexture( "textures/texture_sword/Fabric026_2K_Roughness.jpg" );
                        uniforms2.specularMap.value=loadTexture( "textures/texture_sword/Fabric026_2K_Displacement.jpg" );
                        uniforms2.metalnessMap.value=loadTexture( "textures/texture_sword/Fabric026_2K_Metalness.jpg" );
                        uniforms2.diffuseMap.value=loadTexture( "textures/texture_sword/Fabric026_2K_Color.jpg" );
                        uniforms2.AOMap.value=loadTexture( "textures/texture_sword/Fabric026_2K_AO.jpg" );
                    }
            }

            /*
            funzione che si occupa di gestire il cambiamento del materiale della terza mesh
            */
            function changeM3(x){
                if(x!='glass' && x!='glow'){
                    if(document.getElementById("iem").checked==true){
                        emMesh2.material=altMaterial[2];
                    }else{
                        emMesh2.material=ourMaterial[2];
                    }
                }
                if(copyMesh2!=undefined && x!="glow"){
                        scene.remove(copyMesh2);
                        copyMesh2=undefined;
                    }
                if(x=='metalAxe'){
                        uniforms3.normalMap.value=loadTexture( "textures/texture_axes/Metal032_2K_Normal.jpg" );
                        uniforms3.roughnessMap.value=loadTexture( "textures/texture_axes/Metal032_2K_Roughness.jpg" );
                        uniforms3.specularMap.value=loadTexture( "textures/texture_axes/Metal032_2K_Displacement.jpg" );
                        uniforms3.metalnessMap.value=loadTexture( "textures/texture_axes/Metal032_2K_Metalness.jpg" );
                        uniforms3.diffuseMap.value=loadTexture( "textures/texture_axes/Metal032_2K_Color.jpg" );
                        uniforms3.AOMap.value=loadTexture( "textures/texture_axes/Metal032_2K_AO.jpg" );
                    }else if(x=='goldAxe'){
                        uniforms3.normalMap.value=loadTexture( "textures/texture_axes/Metal034_2K_Normal.jpg" );
                        uniforms3.roughnessMap.value=loadTexture( "textures/texture_axes/Metal034_2K_Roughness.jpg" );
                        uniforms3.specularMap.value=loadTexture( "textures/texture_axes/Metal034_2K_Displacement.jpg" );
                        uniforms3.metalnessMap.value=loadTexture( "textures/texture_axes/Metal034_2K_Metalness.jpg" );
                        uniforms3.diffuseMap.value=loadTexture( "textures/texture_axes/Metal034_2K_Color.jpg" );
                        uniforms3.AOMap.value=loadTexture( "textures/texture_axes/Metal034_2K_AO.jpg" );
                    }else if(x=='woodAxe'){
                        uniforms3.normalMap.value=loadTexture( "textures/texture_axes/WoodSiding009_2K_Normal.jpg" );
                        uniforms3.roughnessMap.value=loadTexture( "textures/texture_axes/WoodSiding009_2K_Roughness.jpg" );
                        uniforms3.specularMap.value=loadTexture( "textures/texture_axes/WoodSiding009_2K_Displacement.jpg" );
                        uniforms3.metalnessMap.value=loadTexture( "textures/texture_axes/WoodSiding009_2K_Metalness.jpg" );
                        uniforms3.diffuseMap.value=loadTexture( "textures/texture_axes/WoodSiding009_2K_Color.jpg" );
                        uniforms3.AOMap.value=loadTexture( "textures/texture_axes/WoodSiding009_2K_AO.jpg" );
                    }else if(x=='blueShield'){
                        uniforms3.normalMap.value=loadTexture( "textures/texture_shield/PaintedMetal003_2K_Normal.jpg");
                        uniforms3.roughnessMap.value=loadTexture( "textures/texture_shield/PaintedMetal003_2K_Roughness.jpg" );
                        uniforms3.specularMap.value=loadTexture( "textures/texture_shield/PaintedMetal003_2K_Displacement.jpg" );
                        uniforms3.metalnessMap.value=loadTexture( "textures/texture_shield/PaintedMetal003_2K_Metalness.jpg" );
                        uniforms3.diffuseMap.value=loadTexture( "textures/texture_shield/PaintedMetal003_2K_Color.jpg" );
                        uniforms3.AOMap.value=loadTexture( "textures/texture_shield/PaintedMetal003_2K_AO.jpg" );
                    }else if(x=='redShield'){
                        uniforms3.normalMap.value=loadTexture( "textures/texture_shield/PaintedMetal004_2K_Normal.jpg");
                        uniforms3.roughnessMap.value=loadTexture( "textures/texture_shield/PaintedMetal004_2K_Roughness.jpg" );
                        uniforms3.specularMap.value=loadTexture( "textures/texture_shield/PaintedMetal004_2K_Displacement.jpg" );
                        uniforms3.metalnessMap.value=loadTexture( "textures/texture_shield/PaintedMetal004_2K_Metalness.jpg" );
                        uniforms3.diffuseMap.value=loadTexture( "textures/texture_shield/PaintedMetal004_2K_Color.jpg" );
                        uniforms3.AOMap.value=loadTexture( "textures/texture_shield/PaintedMetal004_2K_AO.jpg" );
                    }else if(x=='greenShield'){
                        uniforms3.normalMap.value=loadTexture( "textures/texture_shield/PaintedMetal005_2K_Normal.jpg");
                        uniforms3.roughnessMap.value=loadTexture( "textures/texture_shield/PaintedMetal005_2K_Roughness.jpg" );
                        uniforms3.specularMap.value=loadTexture( "textures/texture_shield/PaintedMetal005_2K_Displacement.jpg" );
                        uniforms3.metalnessMap.value=loadTexture( "textures/texture_shield/PaintedMetal005_2K_Metalness.jpg" );
                        uniforms3.diffuseMap.value=loadTexture( "textures/texture_shield/PaintedMetal005_2K_Color.jpg" );
                        uniforms3.AOMap.value=loadTexture( "textures/texture_shield/PaintedMetal005_2K_AO.jpg" );
                    }else if(x=='goldSword'){
                        uniforms3.normalMap.value=loadTexture( "textures/texture_sword/Metal007_2K_Normal.jpg" );
                        uniforms3.roughnessMap.value=loadTexture( "textures/texture_sword/Metal007_2K_Roughness.jpg" );
                        uniforms3.specularMap.value=loadTexture( "textures/texture_sword/Metal007_2K_Displacement.jpg" );
                        uniforms3.metalnessMap.value=loadTexture( "textures/texture_sword/Metal007_2K_Metalness.jpg" );
                        uniforms3.diffuseMap.value=loadTexture( "textures/texture_sword/Metal007_2K_Color.jpg" );
                        uniforms3.AOMap.value=loadTexture( "textures/texture_sword/Metal007_2K_AO.jpg" );
                    }else if(x=='silverSword'){
                        uniforms3.normalMap.value=loadTexture( "textures/texture_sword/Metal005_2K_Normal.jpg" );
                        uniforms3.roughnessMap.value=loadTexture( "textures/texture_sword/Metal005_2K_Roughness.jpg" );
                        uniforms3.specularMap.value=loadTexture( "textures/texture_sword/Metal005_2K_Displacement.jpg" );
                        uniforms3.metalnessMap.value=loadTexture( "textures/texture_sword/Metal005_2K_Metalness.jpg" );
                        uniforms3.diffuseMap.value=loadTexture( "textures/texture_sword/Metal005_2K_Color.jpg" );
                        uniforms3.AOMap.value=loadTexture( "textures/texture_sword/Metal005_2K_AO.jpg" );
                    }else if(x=='glass'){
                        emMesh2.material=glassMaterial[2];
                    }else if(x=='glow'){
                        emMesh2.material=glowMaterial[2];
                        copyMesh2=undefined;
                        copyMesh2=new THREE.Mesh(emMesh2.geometry.clone(),customGlowMaterial);
                        var p =document.getElementById("products").value;
                        if(p!="sickle")copyMesh2.scale.multiplyScalar(0.15);
                        scene.add(copyMesh2);
                        if(p=="axe"){
                            copyMesh2.position.z=emMesh2.position.z;
                        }else if(p=="shield"){
                            copyMesh2.position.z=emMesh2.position.z;
                            copyMesh2.position.x=emMesh2.position.x;
                        }else if(p=="sword"){
                            copyMesh2.rotation.y=emMesh2.rotation.y;
                            copyMesh2.position.y=emMesh2.position.y;
                            copyMesh2.position.y+=0.2;
                        }else{
                            copyMesh2.scale.y=4.6;
                            copyMesh2.scale.x=0.15;
                            copyMesh2.scale.z=0.15;
                        }
                    }else if(x=='goldCasual'){
                        uniforms3.normalMap.value=loadTexture( "textures/prova3.jpg" );
                        uniforms3.roughnessMap.value=loadTexture( "textures/prova6.jpg" );
                        uniforms3.specularMap.value=loadTexture( "textures/prova2.jpg" );
                        uniforms3.metalnessMap.value=loadTexture( "textures/prova4.jpg" );
                        uniforms3.diffuseMap.value=loadTexture( "textures/prova.jpg" );
                        uniforms3.AOMap.value=loadTexture( "textures/prova5.jpg" );
                    }else{
                        uniforms3.normalMap.value=loadTexture( "textures/texture_sword/Fabric026_2K_Normal.jpg" );
                        uniforms3.roughnessMap.value=loadTexture( "textures/texture_sword/Fabric026_2K_Roughness.jpg" );
                        uniforms3.specularMap.value=loadTexture( "textures/texture_sword/Fabric026_2K_Displacement.jpg" );
                        uniforms3.metalnessMap.value=loadTexture( "textures/texture_sword/Fabric026_2K_Metalness.jpg" );
                        uniforms3.diffuseMap.value=loadTexture( "textures/texture_sword/Fabric026_2K_Color.jpg" );
                        uniforms3.AOMap.value=loadTexture( "textures/texture_sword/Fabric026_2K_AO.jpg" );
                    }
            }

            /*
            funzione che si occupa di gestire il cambiamento del materiale della quarta mesh
            */
            function changeM4(x){
                if(x!='glass' && x!='glow'){
                    if(document.getElementById("iem").checked==true){
                        emMesh3.material=altMaterial[3];
                    }else{
                        emMesh3.material=ourMaterial[3];
                    }
                }
                if(copyMesh3!=undefined && x!="glow"){
                        scene.remove(copyMesh3);
                        copyMesh3=undefined;
                    }
                if(x=='metalAxe'){
                        uniforms4.normalMap.value=loadTexture( "textures/texture_axes/Metal032_2K_Normal.jpg" );
                        uniforms4.roughnessMap.value=loadTexture( "textures/texture_axes/Metal032_2K_Roughness.jpg" );
                        uniforms4.specularMap.value=loadTexture( "textures/texture_axes/Metal032_2K_Displacement.jpg" );
                        uniforms4.metalnessMap.value=loadTexture( "textures/texture_axes/Metal032_2K_Metalness.jpg" );
                        uniforms4.diffuseMap.value=loadTexture( "textures/texture_axes/Metal032_2K_Color.jpg" );
                        uniforms4.AOMap.value=loadTexture( "textures/texture_axes/Metal032_2K_AO.jpg" );
                    }else if(x=='goldAxe'){
                        uniforms4.normalMap.value=loadTexture( "textures/texture_axes/Metal034_2K_Normal.jpg" );
                        uniforms4.roughnessMap.value=loadTexture( "textures/texture_axes/Metal034_2K_Roughness.jpg" );
                        uniforms4.specularMap.value=loadTexture( "textures/texture_axes/Metal034_2K_Displacement.jpg" );
                        uniforms4.metalnessMap.value=loadTexture( "textures/texture_axes/Metal034_2K_Metalness.jpg" );
                        uniforms4.diffuseMap.value=loadTexture( "textures/texture_axes/Metal034_2K_Color.jpg" );
                        uniforms4.AOMap.value=loadTexture( "textures/texture_axes/Metal034_2K_AO.jpg" );
                    }else if(x=='woodAxe'){
                        uniforms4.normalMap.value=loadTexture( "textures/texture_axes/WoodSiding009_2K_Normal.jpg" );
                        uniforms4.roughnessMap.value=loadTexture( "textures/texture_axes/WoodSiding009_2K_Roughness.jpg" );
                        uniforms4.specularMap.value=loadTexture( "textures/texture_axes/WoodSiding009_2K_Displacement.jpg" );
                        uniforms4.metalnessMap.value=loadTexture( "textures/texture_axes/WoodSiding009_2K_Metalness.jpg" );
                        uniforms4.diffuseMap.value=loadTexture( "textures/texture_axes/WoodSiding009_2K_Color.jpg" );
                        uniforms4.AOMap.value=loadTexture( "textures/texture_axes/WoodSiding009_2K_AO.jpg" );
                    }else if(x=='blueShield'){
                        uniforms4.normalMap.value=loadTexture( "textures/texture_shield/PaintedMetal003_2K_Normal.jpg");
                        uniforms4.roughnessMap.value=loadTexture( "textures/texture_shield/PaintedMetal003_2K_Roughness.jpg" );
                        uniforms4.specularMap.value=loadTexture( "textures/texture_shield/PaintedMetal003_2K_Displacement.jpg" );
                        uniforms4.metalnessMap.value=loadTexture( "textures/texture_shield/PaintedMetal003_2K_Metalness.jpg" );
                        uniforms4.diffuseMap.value=loadTexture( "textures/texture_shield/PaintedMetal003_2K_Color.jpg" );
                        uniforms4.AOMap.value=loadTexture( "textures/texture_shield/PaintedMetal003_2K_AO.jpg" );
                    }else if(x=='redShield'){
                        uniforms4.normalMap.value=loadTexture( "textures/texture_shield/PaintedMetal004_2K_Normal.jpg");
                        uniforms4.roughnessMap.value=loadTexture( "textures/texture_shield/PaintedMetal004_2K_Roughness.jpg" );
                        uniforms4.specularMap.value=loadTexture( "textures/texture_shield/PaintedMetal004_2K_Displacement.jpg" );
                        uniforms4.metalnessMap.value=loadTexture( "textures/texture_shield/PaintedMetal004_2K_Metalness.jpg" );
                        uniforms4.diffuseMap.value=loadTexture( "textures/texture_shield/PaintedMetal004_2K_Color.jpg" );
                        uniforms4.AOMap.value=loadTexture( "textures/texture_shield/PaintedMetal004_2K_AO.jpg" );
                    }else if(x=='greenShield'){
                        uniforms4.normalMap.value=loadTexture( "textures/texture_shield/PaintedMetal005_2K_Normal.jpg");
                        uniforms4.roughnessMap.value=loadTexture( "textures/texture_shield/PaintedMetal005_2K_Roughness.jpg" );
                        uniforms4.specularMap.value=loadTexture( "textures/texture_shield/PaintedMetal005_2K_Displacement.jpg" );
                        uniforms4.metalnessMap.value=loadTexture( "textures/texture_shield/PaintedMetal005_2K_Metalness.jpg" );
                        uniforms4.diffuseMap.value=loadTexture( "textures/texture_shield/PaintedMetal005_2K_Color.jpg" );
                        uniforms4.AOMap.value=loadTexture( "textures/texture_shield/PaintedMetal005_2K_AO.jpg" );
                    }else if(x=='goldSword'){
                        uniforms4.normalMap.value=loadTexture( "textures/texture_sword/Metal007_2K_Normal.jpg" );
                        uniforms4.roughnessMap.value=loadTexture( "textures/texture_sword/Metal007_2K_Roughness.jpg" );
                        uniforms4.specularMap.value=loadTexture( "textures/texture_sword/Metal007_2K_Displacement.jpg" );
                        uniforms4.metalnessMap.value=loadTexture( "textures/texture_sword/Metal007_2K_Metalness.jpg" );
                        uniforms4.diffuseMap.value=loadTexture( "textures/texture_sword/Metal007_2K_Color.jpg" );
                        uniforms4.AOMap.value=loadTexture( "textures/texture_sword/Metal007_2K_AO.jpg" );
                    }else if(x=='silverSword'){
                        uniforms4.normalMap.value=loadTexture( "textures/texture_sword/Metal005_2K_Normal.jpg" );
                        uniforms4.roughnessMap.value=loadTexture( "textures/texture_sword/Metal005_2K_Roughness.jpg" );
                        uniforms4.specularMap.value=loadTexture( "textures/texture_sword/Metal005_2K_Displacement.jpg" );
                        uniforms4.metalnessMap.value=loadTexture( "textures/texture_sword/Metal005_2K_Metalness.jpg" );
                        uniforms4.diffuseMap.value=loadTexture( "textures/texture_sword/Metal005_2K_Color.jpg" );
                        uniforms4.AOMap.value=loadTexture( "textures/texture_sword/Metal005_2K_AO.jpg" );
                    }else if(x=='glass'){
                        emMesh3.material=glassMaterial[3];
                    }else if(x=='glow'){
                        emMesh3.material=glowMaterial[3];
                        copyMesh3=undefined;
                        copyMesh3=new THREE.Mesh(emMesh3.geometry.clone(),customGlowMaterial);
                        scene.add(copyMesh3);
                        copyMesh3.scale.y=4.6;
                        copyMesh3.scale.x=0.15;
                        copyMesh3.scale.z=0.15;
                    }else if(x=='goldCasual'){
                        uniforms4.normalMap.value=loadTexture( "textures/prova3.jpg" );
                        uniforms4.roughnessMap.value=loadTexture( "textures/prova6.jpg" );
                        uniforms4.specularMap.value=loadTexture( "textures/prova2.jpg" );
                        uniforms4.metalnessMap.value=loadTexture( "textures/prova4.jpg" );
                        uniforms4.diffuseMap.value=loadTexture( "textures/prova.jpg" );
                        uniforms4.AOMap.value=loadTexture( "textures/prova5.jpg" );
                    }else{
                        uniforms4.normalMap.value=loadTexture( "textures/texture_sword/Fabric026_2K_Normal.jpg" );
                        uniforms4.roughnessMap.value=loadTexture( "textures/texture_sword/Fabric026_2K_Roughness.jpg" );
                        uniforms4.specularMap.value=loadTexture( "textures/texture_sword/Fabric026_2K_Displacement.jpg" );
                        uniforms4.metalnessMap.value=loadTexture( "textures/texture_sword/Fabric026_2K_Metalness.jpg" );
                        uniforms4.diffuseMap.value=loadTexture( "textures/texture_sword/Fabric026_2K_Color.jpg" );
                        uniforms4.AOMap.value=loadTexture( "textures/texture_sword/Fabric026_2K_AO.jpg" );
                    }
            }

            /*
            funzione che si occupa di gestire il cambiamento del materiale della quinta mesh
            */
            function changeM5(x){
                if(x!='glass' && x!='glow'){
                    if(document.getElementById("iem").checked==true){
                        emMesh4.material=altMaterial[4];
                    }else{
                        emMesh4.material=ourMaterial[4];
                    }
                }
                if(copyMesh4!=undefined && x!="glow"){
                        scene.remove(copyMesh4);
                        copyMesh4=undefined;
                    }
                if(x=='metalAxe'){
                        uniforms5.normalMap.value=loadTexture( "textures/texture_axes/Metal032_2K_Normal.jpg" );
                        uniforms5.roughnessMap.value=loadTexture( "textures/texture_axes/Metal032_2K_Roughness.jpg" );
                        uniforms5.specularMap.value=loadTexture( "textures/texture_axes/Metal032_2K_Displacement.jpg" );
                        uniforms5.metalnessMap.value=loadTexture( "textures/texture_axes/Metal032_2K_Metalness.jpg" );
                        uniforms5.diffuseMap.value=loadTexture( "textures/texture_axes/Metal032_2K_Color.jpg" );
                        uniforms5.AOMap.value=loadTexture( "textures/texture_axes/Metal032_2K_AO.jpg" );
                    }else if(x=='goldAxe'){
                        uniforms5.normalMap.value=loadTexture( "textures/texture_axes/Metal034_2K_Normal.jpg" );
                        uniforms5.roughnessMap.value=loadTexture( "textures/texture_axes/Metal034_2K_Roughness.jpg" );
                        uniforms5.specularMap.value=loadTexture( "textures/texture_axes/Metal034_2K_Displacement.jpg" );
                        uniforms5.metalnessMap.value=loadTexture( "textures/texture_axes/Metal034_2K_Metalness.jpg" );
                        uniforms5.diffuseMap.value=loadTexture( "textures/texture_axes/Metal034_2K_Color.jpg" );
                        uniforms5.AOMap.value=loadTexture( "textures/texture_axes/Metal034_2K_AO.jpg" );
                    }else if(x=='woodAxe'){
                        uniforms5.normalMap.value=loadTexture( "textures/texture_axes/WoodSiding009_2K_Normal.jpg" );
                        uniforms5.roughnessMap.value=loadTexture( "textures/texture_axes/WoodSiding009_2K_Roughness.jpg" );
                        uniforms5.specularMap.value=loadTexture( "textures/texture_axes/WoodSiding009_2K_Displacement.jpg" );
                        uniforms5.metalnessMap.value=loadTexture( "textures/texture_axes/WoodSiding009_2K_Metalness.jpg" );
                        uniforms5.diffuseMap.value=loadTexture( "textures/texture_axes/WoodSiding009_2K_Color.jpg" );
                        uniforms5.AOMap.value=loadTexture( "textures/texture_axes/WoodSiding009_2K_AO.jpg" );
                    }else if(x=='blueShield'){
                        uniforms5.normalMap.value=loadTexture( "textures/texture_shield/PaintedMetal003_2K_Normal.jpg");
                        uniforms5.roughnessMap.value=loadTexture( "textures/texture_shield/PaintedMetal003_2K_Roughness.jpg" );
                        uniforms5.specularMap.value=loadTexture( "textures/texture_shield/PaintedMetal003_2K_Displacement.jpg" );
                        uniforms5.metalnessMap.value=loadTexture( "textures/texture_shield/PaintedMetal003_2K_Metalness.jpg" );
                        uniforms5.diffuseMap.value=loadTexture( "textures/texture_shield/PaintedMetal003_2K_Color.jpg" );
                        uniforms5.AOMap.value=loadTexture( "textures/texture_shield/PaintedMetal003_2K_AO.jpg" );
                    }else if(x=='redShield'){
                        uniforms5.normalMap.value=loadTexture( "textures/texture_shield/PaintedMetal004_2K_Normal.jpg");
                        uniforms5.roughnessMap.value=loadTexture( "textures/texture_shield/PaintedMetal004_2K_Roughness.jpg" );
                        uniforms5.specularMap.value=loadTexture( "textures/texture_shield/PaintedMetal004_2K_Displacement.jpg" );
                        uniforms5.metalnessMap.value=loadTexture( "textures/texture_shield/PaintedMetal004_2K_Metalness.jpg" );
                        uniforms5.diffuseMap.value=loadTexture( "textures/texture_shield/PaintedMetal004_2K_Color.jpg" );
                        uniforms5.AOMap.value=loadTexture( "textures/texture_shield/PaintedMetal004_2K_AO.jpg" );
                    }else if(x=='greenShield'){
                        uniforms5.normalMap.value=loadTexture( "textures/texture_shield/PaintedMetal005_2K_Normal.jpg");
                        uniforms5.roughnessMap.value=loadTexture( "textures/texture_shield/PaintedMetal005_2K_Roughness.jpg" );
                        uniforms5.specularMap.value=loadTexture( "textures/texture_shield/PaintedMetal005_2K_Displacement.jpg" );
                        uniforms5.metalnessMap.value=loadTexture( "textures/texture_shield/PaintedMetal005_2K_Metalness.jpg" );
                        uniforms5.diffuseMap.value=loadTexture( "textures/texture_shield/PaintedMetal005_2K_Color.jpg" );
                        uniforms5.AOMap.value=loadTexture( "textures/texture_shield/PaintedMetal005_2K_AO.jpg" );
                    }else if(x=='goldSword'){
                        uniforms5.normalMap.value=loadTexture( "textures/texture_sword/Metal007_2K_Normal.jpg" );
                        uniforms5.roughnessMap.value=loadTexture( "textures/texture_sword/Metal007_2K_Roughness.jpg" );
                        uniforms5.specularMap.value=loadTexture( "textures/texture_sword/Metal007_2K_Displacement.jpg" );
                        uniforms5.metalnessMap.value=loadTexture( "textures/texture_sword/Metal007_2K_Metalness.jpg" );
                        uniforms5.diffuseMap.value=loadTexture( "textures/texture_sword/Metal007_2K_Color.jpg" );
                        uniforms5.AOMap.value=loadTexture( "textures/texture_sword/Metal007_2K_AO.jpg" );
                    }else if(x=='silverSword'){
                        uniforms5.normalMap.value=loadTexture( "textures/texture_sword/Metal005_2K_Normal.jpg" );
                        uniforms5.roughnessMap.value=loadTexture( "textures/texture_sword/Metal005_2K_Roughness.jpg" );
                        uniforms5.specularMap.value=loadTexture( "textures/texture_sword/Metal005_2K_Displacement.jpg" );
                        uniforms5.metalnessMap.value=loadTexture( "textures/texture_sword/Metal005_2K_Metalness.jpg" );
                        uniforms5.diffuseMap.value=loadTexture( "textures/texture_sword/Metal005_2K_Color.jpg" );
                        uniforms5.AOMap.value=loadTexture( "textures/texture_sword/Metal005_2K_AO.jpg" );
                    }else if(x=='glass'){
                        emMesh4.material=glassMaterial[4];
                    }else if(x=='glow'){
                        emMesh4.material=glowMaterial[4];
                        copyMesh4=undefined;
                        copyMesh4=new THREE.Mesh(emMesh4.geometry.clone(),customGlowMaterial);
                        scene.add(copyMesh4);
                        copyMesh4.position.y=emMesh4.position.y;
                        copyMesh4.position.x=emMesh4.position.x;
                        copyMesh4.position.z=emMesh4.position.z;
                        copyMesh4.scale.y=4.6;
                        copyMesh4.scale.x=0.15;
                        copyMesh4.scale.z=0.15;
                    }else if(x=='goldCasual'){
                        uniforms5.normalMap.value=loadTexture( "textures/prova3.jpg" );
                        uniforms5.roughnessMap.value=loadTexture( "textures/prova6.jpg" );
                        uniforms5.specularMap.value=loadTexture( "textures/prova2.jpg" );
                        uniforms5.metalnessMap.value=loadTexture( "textures/prova4.jpg" );
                        uniforms5.diffuseMap.value=loadTexture( "textures/prova.jpg" );
                        uniforms5.AOMap.value=loadTexture( "textures/prova5.jpg" );
                    }else{
                        uniforms5.normalMap.value=loadTexture( "textures/texture_sword/Fabric026_2K_Normal.jpg" );
                        uniforms5.roughnessMap.value=loadTexture( "textures/texture_sword/Fabric026_2K_Roughness.jpg" );
                        uniforms5.specularMap.value=loadTexture( "textures/texture_sword/Fabric026_2K_Displacement.jpg" );
                        uniforms5.metalnessMap.value=loadTexture( "textures/texture_sword/Fabric026_2K_Metalness.jpg" );
                        uniforms5.diffuseMap.value=loadTexture( "textures/texture_sword/Fabric026_2K_Color.jpg" );
                        uniforms5.AOMap.value=loadTexture( "textures/texture_sword/Fabric026_2K_AO.jpg" );
                    }
            }
        </script>

		<!-- shaders -->

        <!-- vertex shader definisce gl_Position e passa diversi elementi ai vari fragment shader -->
        <script type="text/x-glsl" id="vertex">
		attribute vec4 tangent;
		varying vec3 vNormal;
        varying vec3 vPosition;
        varying vec3 wPosition;
		varying vec2 vUv;
		varying vec3 vTangent;
        varying vec3 vBitangent;

		void main() {
			vec4 vPos = modelViewMatrix * vec4( position, 1.0 );
            vPosition = vPos.xyz;
            wPosition = (modelMatrix * vec4( position, 1.0 )).xyz;
			vNormal = normalize(normalMatrix * normal);
			vec3 objectTangent = vec3( tangent.xyz );
			vec3 transformedTangent = normalMatrix * objectTangent;
			vTangent = normalize( transformedTangent );
			vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
			vUv = uv;
			gl_Position = projectionMatrix * vPos;
		}
		</script>

        <!-- fragment shader classico che definisce il colore tramite la normale BRDF e aggiunge riflessi speculari -->
		<script type="text/x-glsl" id="fragment">
			varying vec3 vNormal;
			varying vec3 vTangent;
			varying vec3 vBitangent;
            varying vec3 vPosition;
            varying vec3 wPosition;
			varying vec2 vUv;
			uniform vec3 clight;
            uniform sampler2D normalMap;
            uniform sampler2D roughnessMap;
            uniform sampler2D specularMap;
            uniform sampler2D metalnessMap;
            uniform sampler2D diffuseMap;
            uniform sampler2D AOMap;
            uniform sampler2D glowMap;
            uniform samplerCube envMap;
            uniform vec2 textureRepeat;
            uniform vec2 normalScale;
            uniform vec3 pointLightPosition;
            uniform float intensity;
            const float PI = 3.14159;
            uniform vec3 emissiveC;
            uniform sampler2D noiseTexture;
            uniform float time;
            float speed=0.25;
            uniform float animEn;		
			#define saturate(a) clamp( a, 0.0, 1.0 )
            vec3 metalness;
            vec3 cdiff;
            vec3 cspec;
			float roughness;
            
            /*
            funzione che converte albedo e metal in cspec
            */
			vec3 getCSpec(vec3 albedo, vec3 metal){  
				float r = max(metal.r, 0.2196) * albedo.r; //0.2196 e' #383838
				float g = max(metal.g, 0.2196) * albedo.g;
				float b = max(metal.b, 0.2196) * albedo.b;
				return vec3(r,g,b);
			}

			float pow2( const in float x ) { return x*x; }

            /*
            funzione che usa il valore di rufosità espresso come blinnShininessExponent per accedere alla MipMap
            */
			float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {
				float maxMIPLevelScalar = float( maxMIPLevel );
				float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );
				return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
			}

            /*
            funzione che converte rugosità per poter accedere al livello MipMap
            */
			float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
				return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
			}

			vec3 FSchlick(float vDoth, vec3 f0) {
				return f0 + (vec3(1.0)-f0)*pow(1.0 - vDoth,5.0);
			}

			float DGGX(float NoH, float alpha) {
				float alpha2 = alpha * alpha;
				float k = NoH*NoH * (alpha2 - 1.0) + 1.0;
    			return alpha2 / (PI * k * k );
			}

			float G1(float nDotv, float alpha) {
				float alpha2 = alpha*alpha;
				return 2.0 * (nDotv / (nDotv + sqrt(alpha2 + (1.0-alpha2)*nDotv*nDotv )));
			}

			float GSmith(float nDotv, float nDotl, float alpha) {
				return G1(nDotl,alpha)*G1(nDotv,alpha);
            }
            
            vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
                return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
			}
			
			vec3 BRDF_Specular_GGX_Environment( vec3 normal, vec3 viewDir, const in vec3 cspec, const in float roughness ) {

				float dotNV = saturate( dot( normal, viewDir ) );
				const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
				const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
				vec4 r = roughness * c0 + c1;
				float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
				vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;
				return cspec * AB.x + AB.y;

			}

			void main() {
				vec4 lPosition = viewMatrix * vec4( pointLightPosition, 1.0 );
				vec3 l = normalize(lPosition.xyz - vPosition.xyz);
				vec3 normal = normalize( vNormal );
				vec3 tangent = normalize( vTangent );
				vec3 bitangent = normalize( vBitangent );
				mat3 vTBN = mat3( tangent, bitangent, normal );
				vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
				vec3 n = normalize( vTBN * mapN );
				vec3 v = normalize( -vPosition);
				vec3 h = normalize( v + l);
				float nDotl = max(dot( n, l ),0.000001);
				float lDoth = max(dot( l, h ),0.000001);
				float nDoth = max(dot( n, h ),0.000001);
				float vDoth = max(dot( v, h ),0.000001);
                float nDotv = max(dot( n, v ),0.000001);
                vec3 worldN = inverseTransformDirection( n, viewMatrix );
				vec3 worldV = cameraPosition - wPosition ;
                vec3 r = normalize( reflect(-worldV,worldN));
                metalness = texture2D( metalnessMap, vUv*textureRepeat).rgb;
                metalness = pow( metalness, vec3(2.2));
                if(animEn>0.5){
                    vec2 uvTimeShift = vUv + vec2( -2.5, 1.5 ) * time * speed;	
                    vec4 noiseGeneratorTimeShift = texture2D( noiseTexture, uvTimeShift );
                    vec2 uvNoiseTimeShift = vUv + 0.5 * vec2( noiseGeneratorTimeShift.r, noiseGeneratorTimeShift.b );
                    cdiff = texture2D( diffuseMap, uvNoiseTimeShift ).rgb;
                }else{
                    cdiff=texture2D( diffuseMap, vUv*textureRepeat ).rgb;
                }
				cdiff = pow( cdiff, vec3(2.2));
				cspec = getCSpec(cdiff, metalness);
				cdiff = cdiff*(vec3(1)-metalness);
                roughness = texture2D( roughnessMap, vUv*textureRepeat).r;
                vec3 fresnel = FSchlick(vDoth, cspec);
                vec3 outRadiance;
				float alpha = roughness * roughness;
				float blinnShininessExponent = GGXRoughnessToBlinnExponent(roughness);
				float specularMIPLevel = getSpecularMIPLevel(blinnShininessExponent, 8 );
                vec3 envLight = textureCube( envMap, vec3(-r.x, r.yz),specularMIPLevel).rgb;
                envLight = pow( envLight, vec3(2.2));
                outRadiance+=envLight*BRDF_Specular_GGX_Environment(n, v, cspec, roughness);
                outRadiance = outRadiance + envLight*(cdiff*texture2D( AOMap, vUv ).xyz).xyz * 0.2;
                vec3 BRDF = (vec3(1.0)-fresnel)*cdiff/PI + fresnel*GSmith(nDotv,nDotl, alpha)*DGGX(nDoth,alpha)/
                    (4.0*nDotl*nDotv);
                outRadiance = outRadiance + PI* clight * nDotl * BRDF;//*5.0
				gl_FragColor = vec4(pow( outRadiance * intensity, vec3(1.0/2.2)), 1.0);
			}
        </script>

        <!-- fragment shader che non restituisce un colore riflessivo, ma combina irradiance map con cdiff -->
        <script type="text/x-glsl" id="fragmentIrr">
			varying vec3 vNormal;
			varying vec3 vTangent;
			varying vec3 vBitangent;
            varying vec3 vPosition;
            varying vec3 wPosition;
			varying vec2 vUv;
            uniform sampler2D diffuseMap;
            uniform sampler2D normalMap;
            uniform samplerCube irradianceMap;
            uniform vec2 textureRepeat;
            uniform float intensity;
            uniform sampler2D noiseTexture;
            uniform float time;
            float speed=0.25;
            uniform float animEn;

            vec3 cdiff;
            
            vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
                return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
			}

			void main() {

                vec3 normal = normalize( vNormal );
				vec3 tangent = normalize( vTangent );
				vec3 bitangent = normalize( vBitangent );
				mat3 vTBN = mat3( tangent, bitangent, normal );
				vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
				vec3 n = normalize( vTBN * mapN );
				vec3 v = normalize( -vPosition);
				vec3 worldN = inverseTransformDirection( n, viewMatrix );
				vec3 worldV = cameraPosition - wPosition ;
				vec3 r = normalize( reflect(-worldV,worldN));
				float nDotv = max(dot( n, v ),0.000001);
				vec3 irradiance = textureCube( irradianceMap, worldN).rgb;
                irradiance = pow( irradiance, vec3(2.2));
                if(animEn>0.5){
                    vec2 uvTimeShift = vUv + vec2( -2.5, 1.5 ) * time * speed;	
                    vec4 noiseGeneratorTimeShift = texture2D( noiseTexture, uvTimeShift );
                    vec2 uvNoiseTimeShift = vUv + 0.5 * vec2( noiseGeneratorTimeShift.r, noiseGeneratorTimeShift.b );
                    cdiff = texture2D( diffuseMap, uvNoiseTimeShift ).rgb;
                }else{
                    cdiff=texture2D( diffuseMap, vUv*textureRepeat ).rgb;
                }
				cdiff = pow( cdiff, vec3(2.2));
				vec3 outRadiance = cdiff*irradiance;
				gl_FragColor = vec4(pow( outRadiance * intensity, vec3(1.0/2.2)), 1.0);
			}
        </script>

        <!-- fragment che aggiunge effetto glow al materiale-->
        <script type="text/x-glsl" id="fragmentGlow">
			varying vec3 vNormal;
			varying vec3 vTangent;
			varying vec3 vBitangent;
            varying vec3 vPosition;
            varying vec3 wPosition;
			varying vec2 vUv;
            uniform sampler2D diffuseMap;
            uniform sampler2D normalMap;
            uniform samplerCube irradianceMap;
            uniform vec2 textureRepeat;
            uniform sampler2D glowMap;
            uniform vec3 emissiveC;
            uniform float intensity;
            vec3 cdiff;
            
            vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
                return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
            }
            
            //https://github.com/mistic100/three.js-examples/blob/master/examples/js/shaders/LuminosityHighPassShader.js

			void main() {

                vec4 glow=texture2D(glowMap,vUv*textureRepeat)*30.0*2.0;
                glow.rgb*=emissiveC;
                vec3 luma = vec3( 0.299, 0.587, 0.114 );
                float lg = dot( glow.xyz, luma );//calcolo luminanza Digital ITU BT.601 https://stackoverflow.com/questions/596216/formula-to-determine-brightness-of-rgb-color
                vec4 outputColor = vec4( (texture2D(diffuseMap,vUv*textureRepeat)).rgb, 1.0 );
                float alphagl = smoothstep( 2.0, 3.0, lg );//https://en.wikipedia.org/wiki/Smoothstep
                //se lg<2.0-->outputcolor se lg>3.0-->glow

                //float alphagl = clamp((lg - 1.0) / (2.0 - 1.0), 0.0, 1.0);
                //alphagl= alphagl * alphagl * (3.0 - 2.0 * alphagl);
                    
                vec4 risult_int=mix( outputColor, glow, alphagl );//interpola outputcolor e glow con valore alphagl
                //https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/mix.xhtml
                vec3 outRadiance=risult_int.xyz;
                gl_FragColor = vec4(pow( outRadiance* intensity, vec3(1.0/2.2)), 1.0);
			}
        </script>

        <!-- vertex shader custom che gestisce l'effetto glow-->
        <script type="text/x-glsl" id="vertexCustomGlow">
            uniform vec3 viewVector;//vettore della vista dalla camera
            uniform float c;//fattore di confronto del dot product tra viewVector e normale, valori bassi nascondono l'effetto
            uniform float p;//potenza dell'effetto, più è basso più è forte, valori alti portano a risultati molto trasparenti
            varying float rangeIntensity;//fattore da passare al fragment shader
    
            void main() {
                vec3 vNormal = normalize( normalMatrix * normal );//normal in word space
                vec3 vNormel = normalize( normalMatrix * viewVector );//viewVector in word space (calculate a viewVector uniform, or the angle at which we are viewing the object)
                rangeIntensity = pow( c - dot(vNormal, vNormel), p );//power of a constant (c) minus the current normal in relation to view times p
                //(legge coseno lambert)
                gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
            }
        </script>

        <!-- fragment shader custom che gestisce l'effetto glow-->
        <script type="text/x-glsl" id="fragmentCustomGlow">
			uniform vec3 glowColor;
            varying float rangeIntensity;

            
			void main() {
                vec3 glow = glowColor * rangeIntensity;
                gl_FragColor = vec4( glow, 1.0 );
			}
        </script>

        <!-- fragment shader che gestisce l'effetto glass-->
        <script type="text/x-glsl" id="fragmentGlass">
			varying vec3 vNormal;
			varying vec3 vTangent;
			varying vec3 vBitangent;
            varying vec3 vPosition;
            varying vec3 wPosition;
			varying vec2 vUv;
            uniform sampler2D diffuseMap;
            uniform sampler2D normalMap;
            uniform sampler2D specularMap;
            uniform sampler2D metalnessMap;
            uniform samplerCube irradianceMap;
            uniform sampler2D roughnessMap;
            uniform vec2 textureRepeat;
            uniform vec3 pointLightPosition;
            uniform vec2 normalScale;
            uniform samplerCube envMap;
            uniform float intensity;
            vec3 cdiff;
            vec3 cspec;
            vec3 metalness;
            float roughness;

            vec3 getCSpec(vec3 albedo, vec3 metal){  
				float r = max(metal.r, 0.2196) * albedo.r; //0.2196 e' #383838
				float g = max(metal.g, 0.2196) * albedo.g;
				float b = max(metal.b, 0.2196) * albedo.b;
				return vec3(r,g,b);
			}
            
            vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
                return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
            }
            
            vec3 FSchlick(float vDoth, vec3 f0) {
				return f0 + (vec3(1.0)-f0)*pow(1.0 - vDoth,5.0);
            }
            
            float pow2( const in float x ) { return x*x; }

			float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {
				float maxMIPLevelScalar = float( maxMIPLevel );
				float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );
				return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
			}

			float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
				return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
			}

			void main() {

                vec4 lPosition = viewMatrix * vec4( pointLightPosition, 1.0 );
				vec3 l = normalize(lPosition.xyz - vPosition.xyz);
				vec3 normal = normalize( vNormal );
				vec3 tangent = normalize( vTangent );
				vec3 bitangent = normalize( vBitangent );
				mat3 vTBN = mat3( tangent, bitangent, normal );
				vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
				vec3 n = normalize( vTBN * mapN );
				vec3 v = normalize( -vPosition);
				vec3 h = normalize( v + l);
				float nDotl = max(dot( n, l ),0.000001);
				float lDoth = max(dot( l, h ),0.000001);
				float nDoth = max(dot( n, h ),0.000001);
				float vDoth = max(dot( v, h ),0.000001);
                float nDotv = max(dot( n, v ),0.000001);
                vec3 worldN = inverseTransformDirection( n, viewMatrix );
                vec3 worldV = cameraPosition - wPosition ;
                
                metalness = texture2D( metalnessMap, vUv*textureRepeat).rgb;
                metalness = pow( metalness, vec3(2.2));
                cdiff=texture2D( diffuseMap, vUv*textureRepeat ).rgb;
				cdiff = pow( cdiff, vec3(2.2));
				cspec = getCSpec(cdiff, metalness);
				cdiff = cdiff*(vec3(1)-metalness);
                vec3 fresnel = FSchlick(vDoth, cspec);
                mapN.xy = normalScale * mapN.xy;
                vec3 rRifr = normalize( refract(-worldV,worldN,1.0/2.42));//n1/n2-->3.0/3.0
                vec3 envLightRifr=textureCube( envMap, vec3(-rRifr.x, rRifr.yz)).rgb;
                envLightRifr = pow( envLightRifr, vec3(2.2));
                vec3 r = normalize( reflect(-worldV,worldN));
                roughness = texture2D( roughnessMap, vUv*textureRepeat).r;
                float alpha = roughness * roughness;
				float blinnShininessExponent = GGXRoughnessToBlinnExponent(roughness);
				float specularMIPLevel = getSpecularMIPLevel(blinnShininessExponent, 8 );
                vec3 envLight = textureCube( envMap, vec3(-r.x, r.yz),specularMIPLevel).rgb;
                envLight = pow( envLight, vec3(2.2));


                vec3 outRadiance=vec3(255.0,15.0,0.0)*(vec3(1.0)-fresnel)*envLightRifr+fresnel*envLight;
                gl_FragColor = vec4(pow( outRadiance*intensity, vec3(1.0/2.2)), 0.5);


			}
        </script>

		<!-- three.js code -->

		<script>

            /*
            variabile che definisce l'effetto god rays globale
            */
            THREE.VolumetericLightShader = {
                    uniforms: {
                        tDiffuse: {value:null},//texture dalla passata precedente
                        lightPosition: {value: new THREE.Vector2(0.5, 0.5)},//posizione luci, se non definita è 0.5,0.5
                        exposure: {value: 0.18},//esposizione, se non definita è 0.18(intensità luminosa complessiva)
                        decay: {value: 0.95},//decadimento, se non definito è 0.95(controlla la caduta della sorgente luminosa)
                        density: {value: 0.8},//densità, se non definita è 0.8(separazione tra i campioni, se aumentato la separazione si riduce)
                        weight: {value: 0.4},//peso, se non definita è 0.4(peso secondario sulla luminosità complessiva)
                        samples: {value: 50}//numero campioni, se non definito è 50
                    },

                    vertexShader: [//definisci gl_Position e passa al fragment uv
                        "varying vec2 vUv;",
                        "void main() {",
                        "vUv = uv;",
                        "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
                        "}"
                    ].join("\n"),

                    fragmentShader: [
                        "varying vec2 vUv;",
                        "uniform sampler2D tDiffuse;",
                        "uniform vec2 lightPosition;",
                        "uniform float exposure;",
                        "uniform float decay;",
                        "uniform float density;",
                        "uniform float weight;",
                        "uniform int samples;",
                        "const int MAX_SAMPLES = 100;",
                        "void main()",
                        "{",
                        "vec2 texCoord = vUv;",//ottienmi le coordinate del tex
                        "vec2 deltaTextCoord = texCoord - lightPosition;",// Calculate vector from pixel to light source in screen space
                        "deltaTextCoord *= 1.0 / float(samples) * density;",// Divide by number of samples and scale by control factor
                        "vec4 color = texture2D(tDiffuse, texCoord);",// Store initial sample
                        "float illuminationDecay = 1.0;",// set up illumination decay factor
                        "for(int i=0; i < MAX_SAMPLES; i++)",// evaluate the summation for samples number of iterations up to 100
                        "{",
                            "if(i == samples){",// work around for dynamic number of loop iterations
                            "break;",
                            "}",
                            "texCoord -= deltaTextCoord;",// step sample location along ray
                            "vec4 sampleI = texture2D(tDiffuse, texCoord);",// retrieve sample at new location
                            "sampleI *= illuminationDecay * weight;",// apply sample attenuation scale/decay factors
                            "color += sampleI;",// accumulate combined color
                            "illuminationDecay *= decay;",// update exponential decay factor
                        "}",
                        "gl_FragColor = color * exposure;",// output final color with a further scale control factor
                        "}"
                    ].join("\n")
                    };

            /*
            variabile che definisce lo shader per il blur verticale
            */
            var blurShaderV = {

			uniforms: {
				"tDiffuse": { type: "t", value: null },//texture della precedente passata
                "v":        { type: "f", value: 1.0 / window.innerHeight }//reciproco della risoluzione verticale
            },

			vertexShader: [//definisci gl_Position e passa al fragment uv
				"varying vec2 vUv;",
				"void main() {",
					"vUv = uv;",
					"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
				"}"
			].join("\n"),
			fragmentShader: [
				"uniform sampler2D tDiffuse;",
				"varying vec2 vUv;",
                "uniform float v;",
				"void main(void)",
				"{",
                   "vec4 sum = vec4( 0.0 );",//inizializza sum a 0

                    "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 4.0 * v ) ) * 0.051;",
                    "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 3.0 * v ) ) * 0.0918;",
                    "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 2.0 * v ) ) * 0.12245;",
                    "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y - 1.0 * v ) ) * 0.1531;",//sotto
                    "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;",//centro
                    "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 1.0 * v ) ) * 0.1531;",//sopra
                    "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 2.0 * v ) ) * 0.12245;",
                    "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 3.0 * v ) ) * 0.0918;",
                    "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y + 4.0 * v ) ) * 0.051;",
                    //influenza la coordinata y di vUv con v

                    "gl_FragColor = sum;",
            "}"
			].join("\n")
        };

        var fxaa={
            uniforms:{
                "tDiffuse": { type: "t", value: null },
                "resolution":        { type: "v2", value: new THREE.Vector2(window.innerWidth,window.innerHeight) }
            },

            vertexShader: [

                      
                    "varying vec2 vUv;",

                    "varying vec2 v_rgbNW;",
                    "varying vec2 v_rgbNE;",
                    "varying vec2 v_rgbSW;",
                    "varying vec2 v_rgbSE;",
                    "varying vec2 v_rgbM;",

                    "uniform vec2 resolution;",

                    "void main() {",
                    "vUv = uv;",
                    "vec2 fragCoord = uv * resolution;",//determina coordinate frammento
                    "highp vec2 inverseVP = 1.0 / resolution.xy;",//inverso risoluzione
                    "v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;",
                    "v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;",
                    "v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;",
                    "v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;",
                    "v_rgbM = vec2(fragCoord * inverseVP);",

                    "gl_Position = projectionMatrix *modelViewMatrix *vec4(position,1.0);",
                    "}"
                ].join("\n"),

            fragmentShader: [

                //http://developer.download.nvidia.com/assets/gamedev/files/sdk/11/FXAA_WhitePaper.pdf
                //https://github.com/demoscenepassivist/SocialCoding/blob/master/code_demos_jogamp/shaders/fxaa.fs


               " varying vec2 vUv;",

                //texcoords computed in vertex step
                //to avoid dependent texture reads
                "varying vec2 v_rgbNW;",
                "varying vec2 v_rgbNE;",
                "varying vec2 v_rgbSW;",
                "varying vec2 v_rgbSE;",
                "varying vec2 v_rgbM;",

                //make sure to have a resolution uniform set to the screen size
                "uniform vec2 resolution;",
                "uniform sampler2D tDiffuse;",

                "#define FXAA_REDUCE_MIN   (1.0/ 128.0)",//minimum reduce scale
                "#define FXAA_REDUCE_MUL   (1.0 / 8.0)",//reduce scale multiplier
                "#define FXAA_SPAN_MAX     8.0",//will force clamp the sample range

                //https://en.wikipedia.org/wiki/Fast_approximate_anti-aliasing
                //https://reshade.me/forum/shader-discussion/1641-fxaa-parameter-confusion
                //https://studylib.net/doc/5611053/fxaa-3.11-in-15-slides
                //https://catlikecoding.com/unity/tutorials/advanced-rendering/fxaa/


                "vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,vec2 v_rgbNW, vec2 v_rgbNE,vec2 v_rgbSW, vec2 v_rgbSE,vec2 v_rgbM) {",
                    "vec4 color;",
                    "highp vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);",//inverso risoluzione
                    "vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;",//colore nord ovest
                    "vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;",//colore nord est
                    "vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;",//colore sud ovest
                    "vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;",//colore sud est
                    "vec4 texColor = texture2D(tex, v_rgbM);",
                    "vec3 rgbM  = texColor.xyz;",//colore centro
                    "vec3 luma = vec3(0.299, 0.587, 0.114);",//vettore di luminanza
                    "float lumaNW = dot(rgbNW, luma);",//luminanza nord ovest
                    "float lumaNE = dot(rgbNE, luma);",//luminanza nord est
                    "float lumaSW = dot(rgbSW, luma);",//luminanza sud ovest
                    "float lumaSE = dot(rgbSE, luma);",//luminanza sud est
                    "float lumaM  = dot(rgbM,  luma);",//luminanza centro
                    "float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));",//luminanza min
                    "float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));",//luminanza max
                    
                    "highp vec2 dir;",
                    "dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));",//distanza tra luminanza superiore e inferiore 
                    "dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));",//distanza tra luminanza destra e sinistra 
                    
                    "float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *(0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);",//fattore di riduzione distanza media 4 luminanze
                    
                    "float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);",//reciproco minima luminanza con riduzione applicata
                    "dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),dir * rcpDirMin)) * inverseVP;",//aggiusta fattore di distanza luminanza(inverseVP per applicare effetto al solo oggetto)
                    "vec3 rgbA = 0.5 * (texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 + 0.5)).xyz);",//colore centrale(Controls removal of sub-pixel aliasing)
                    "vec3 rgbB = rgbA *0.5+ 0.25 * (texture2D(tex, fragCoord * inverseVP + dir * (0.0/3.0 -0.5)).xyz +texture2D(tex, fragCoord * inverseVP + dir * (3.0/3.0 - 0.5)).xyz);",//colore bordi

                    "float lumaB = dot(rgbB, luma);",//luminanza bordi
                    "if ((lumaB < lumaMin) || (lumaB > lumaMax))",//se luminanza bordi oltre il range valido
                        "color = vec4(rgbA, texColor.a);",//retituisci colore a
                    "else",
                        "color = vec4(rgbB, texColor.a);",//altrimenti il b
                    "return color;",
                "}",

                "void main() {",
                "vec2 fragCoord = vUv * resolution;   ",
                "gl_FragColor = fxaa(tDiffuse, fragCoord, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);",
                "}"

            ].join("\n")
        };
        
            /*
            variabile che definisce lo shader per il blur orizzontale
            */
            var blurShaderO = {

                uniforms: {
                    "tDiffuse": { type: "t", value: null },//texture della precedente passata
                    "h":        { type: "f", value: 1.0 / window.innerWidth }//reciproco della risoluzione orizzontale
                },

                vertexShader: [//definisci gl_Position e passa al fragment uv
                    "varying vec2 vUv;",
                    "void main() {",
                        "vUv = uv;",
                        "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
                    "}"
                ].join("\n"),

                fragmentShader: [
                    "uniform sampler2D tDiffuse;",
                    "varying vec2 vUv;",
                    "uniform float h;",
                    "void main(void)",
                    "{",
                        "vec4 sum = vec4( 0.0 );",//inizializza sum a 0

                        "sum += texture2D( tDiffuse, vec2( vUv.x - 4.0 * h, vUv.y ) ) * 0.051;",
                        "sum += texture2D( tDiffuse, vec2( vUv.x - 3.0 * h, vUv.y ) ) * 0.0918;",
                        "sum += texture2D( tDiffuse, vec2( vUv.x - 2.0 * h, vUv.y ) ) * 0.12245;",
                        "sum += texture2D( tDiffuse, vec2( vUv.x - 1.0 * h, vUv.y ) ) * 0.1531;",//sx
                        "sum += texture2D( tDiffuse, vec2( vUv.x, vUv.y ) ) * 0.1633;",//centro
                        "sum += texture2D( tDiffuse, vec2( vUv.x + 1.0 * h, vUv.y ) ) * 0.1531;",//dx
                        "sum += texture2D( tDiffuse, vec2( vUv.x + 2.0 * h, vUv.y ) ) * 0.12245;",
                        "sum += texture2D( tDiffuse, vec2( vUv.x + 3.0 * h, vUv.y ) ) * 0.0918;",
                        "sum += texture2D( tDiffuse, vec2( vUv.x + 4.0 * h, vUv.y ) ) * 0.051;",
                        //influenza la coordinata x di vUv con h

                        "gl_FragColor = sum;",
                "}"
                ].join("\n")
            };

            /*
            variabile che rappresenta lo shader per l'effetto film con grana
            */
            var FilmGrain = {

            uniforms: {
                "tDiffuse": { type: "t", value: null },//texture della precedente passata
                "amount":        { type: "f", value: 5.0 }//float che rappresenta la forza dell'effetto
            },

            vertexShader: [//definisci gl_Position e passa al fragment uv
                "varying vec2 vUv;",
                "void main() {",
                    "vUv = uv;",
                    "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
                "}"
            ].join("\n"),

            fragmentShader: [
                "uniform sampler2D tDiffuse;",
                "varying vec2 vUv;",
                "uniform float amount;",

                "float random( vec2 p )",//funzione casuale per randomizzare posizione della texture noise
                "{",
                   " vec2 K1 = vec2(",
                        "23.14069263277926,", // e^pi (Gelfond's constant)
                        "2.665144142690225", // 2^sqrt(2) (Gelfond–Schneider constant)
                    ");",
                    "return fract( cos( dot(p,K1) ) * 12345.6789 );",//ritorna la parte frazionale del prodotto di 12345.6789 con il coseno del dot product di p e k1
                "}",

                "void main()",
                "{",
                    "vec4 color = texture2D( tDiffuse, vUv );",//colore ottenuto dalla texture della passata precedente
                    "vec2 uvRandom = vUv;",//copia vUv
                    "uvRandom.y *= random(vec2(uvRandom.y,amount));",//randomizza la componente y di uvRandom con un valore pari ad amount
                    "color.rgb += random(uvRandom)*0.15;",//randomizza ulteriormente uvRandom moltiplicalo per 0.15 e somma questo valore alle componenti rgb di color
                    //moltiplicazione per controllare la granulosità
                    "gl_FragColor = vec4( color );",
            "}"
            ].join("\n")
            };

            var toneMap_ACES={
                //https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl
                //***** https://computergraphics.stackexchange.com/questions/9834/how-to-convert-from-xyz-or-srgb-to-acescg-ap1
                //https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs
                //https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/
                //https://www.shadertoy.com/view/WltSRB

                uniforms: {
                "tDiffuse": { type: "t", value: null },//texture della precedente passata
            },

            vertexShader: [//definisci gl_Position e passa al fragment uv
                "varying vec2 vUv;",
                "void main() {",
                    "vUv = uv;",
                    "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",
                "}"
            ].join("\n"),

            // The code in this file was originally written by Stephen Hill (@self_shadow), who deserves all
            // credit for coming up with this fit and implementing it. Buy him a beer next time you see him.
            //This is the default TMO used by Unreal Engine 4
            //https://64.github.io/tonemapping/
            //https://gist.github.com/SpineyPete/ebf9619f009318536c6da48209894fed

            fragmentShader: [
                "uniform sampler2D tDiffuse;",
                "varying vec2 vUv;",

                    "vec3 rrt_odt_fit(vec3 v)",
                    "{",
                        "vec3 a = v*(         v + 0.0245786) - 0.000090537;",
                        "vec3 b = v*(0.983729*v + 0.4329510) + 0.238081;",
                        "return a/b;//(v*(2.51*v+0.03))/(v*(2.43*v+0.59)+0.14);",
                    "}",

                   " mat3 mat3_from_rows(vec3 c0, vec3 c1, vec3 c2)",
                    "{",
                        "mat3 m = mat3(c0, c1, c2);",
                        "m = transpose(m);",

                        "return m;",
                    "}",

                    "vec3 mul(mat3 m, vec3 v)",
                    "{",
                        "return m * v;",
                    "}",

                    "float saturate(float v)",
                    "{",
                        "return clamp(v, 0.0, 1.0);",
                    "}",

                    "vec3 saturate(vec3 v)",
                    "{",
                        "return vec3(saturate(v.x), saturate(v.y), saturate(v.z));",
                    "}",

                    //https://acescolorspace.com/
                    //https://en.wikipedia.org/wiki/Academy_Color_Encoding_System
                    "vec3 aces_fitted(vec3 color)",
                    "{",
                        //“ACES Primaries” #1
                        // sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT //The Reference Rendering Transform 
                        "mat3 ACES_INPUT_MAT = mat3_from_rows(",
                            "vec3( 0.59719, 0.35458, 0.04823),",
                            "vec3( 0.07600, 0.90834, 0.01566),",
                            "vec3( 0.02840, 0.13383, 0.83777));",

                        //The Output Display Transform
                        // ODT_SAT => XYZ => D60_2_D65 => sRGB
                        "mat3 ACES_OUTPUT_MAT = mat3_from_rows(",
                            "vec3( 1.60475,-0.53108,-0.07367),",
                            "vec3(-0.10208, 1.10813,-0.00605),",
                            "vec3(-0.00327,-0.07276, 1.07602));",

                        "color = mul(ACES_INPUT_MAT, color);",

                        // Apply RRT and ODT
                        "color = rrt_odt_fit(color);",

                        "color = mul(ACES_OUTPUT_MAT, color);",

                        // Clamp to [0, 1]
                        "color = saturate(color);",

                        "return color;",
                    "}",

                    "void main()",
                    "{",
                        "vec4 color = texture2D( tDiffuse, vUv );",//colore ottenuto dalla texture della passata precedente
                        "gl_FragColor = vec4( aces_fitted(color.rgb),color.a );",
            "}"
            ].join("\n")

            };

            //variabili per la gestione delle texture, dell'oggetto 3d, dei parametri d'interazione con l'utente
            var renderer = new THREE.WebGLRenderer({ canvas: productCanvas , antialias: true } );
			var camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1.0, 50000.0 );
			var controls = new THREE.OrbitControls( camera, renderer.domElement );
			var scene = new THREE.Scene();
            var obj=new THREE.Object3D();
            var hemL;
            var dirL;
            var config=0;
            scene.add(obj);  
            var composer;
            var ok=0;
            var emMesh;
            var emMesh1;
            var emMesh2;
            var emMesh3;
            var emMesh4;
            var clock=new THREE.Clock();
            var filmpass;
            var copyMesh;
            var copyMesh1;
            var copyMesh2;
            var copyMesh3;
            var copyMesh4;
            var aces_TM;
            var fxaa;

			var normalMap1 = loadTexture( "textures/texture_axes/Metal032_2K_Normal.jpg" );
            var normalMap2 = loadTexture( "textures/texture_axes/Metal034_2K_Normal.jpg" );
            var normalMap3 = loadTexture( "textures/texture_axes/WoodSiding009_2K_Normal.jpg" );
            var normalMap4 = loadTexture( "textures/texture_sword/Metal007_2K_Normal.jpg" );
            var normalMap5 = loadTexture( "textures/texture_shield/PaintedMetal004_2K_Normal.jpg" );
            
            var roughness1 = loadTexture( "textures/texture_axes/Metal032_2K_Roughness.jpg" );
            var roughness2 = loadTexture( "textures/texture_axes/Metal034_2K_Roughness.jpg" );
            var roughness3 = loadTexture( "textures/texture_axes/WoodSiding009_2K_Roughness.jpg" );
            var roughness4 = loadTexture( "textures/texture_sword/Metal007_2K_Roughness.jpg" );
            var roughness5 = loadTexture( "textures/texture_shield/PaintedMetal004_2K_Roughness.jpg" );
            

            var specularMap1 = loadTexture( "textures/texture_axes/Metal032_2K_Displacement.jpg" );
            var specularMap2 = loadTexture( "textures/texture_axes/Metal034_2K_Displacement.jpg" );
            var specularMap3 = loadTexture( "textures/texture_axes/WoodSiding009_2K_Displacement.jpg" );
            var specularMap4 = loadTexture( "textures/texture_sword/Metal007_2K_Displacement.jpg" );
            var specularMap5 = loadTexture( "textures/texture_shield/PaintedMetal004_2K_Displacement.jpg" );

            var diffuseMap1 = loadTexture( "textures/texture_axes/Metal032_2K_Color.jpg" );
            var diffuseMap2 = loadTexture( "textures/texture_axes/Metal034_2K_Color.jpg" );
            var diffuseMap3 = loadTexture( "textures/texture_axes/WoodSiding009_2K_Color.jpg" );
            var diffuseMap4 = loadTexture( "textures/texture_sword/Metal007_2K_Color.jpg" );
            var diffuseMap5 = loadTexture( "textures/texture_shield/PaintedMetal004_2K_Color.jpg" );

            var metalnessMap1 = loadTexture( "textures/texture_axes/Metal032_2K_Metalness.jpg" );
            var metalnessMap2 = loadTexture( "textures/texture_axes/Metal034_2K_Metalness.jpg" );
			var metalnessMap3 = loadTexture( "textures/texture_axes/WoodSiding009_2K_Metalness.jpg" );
            var metalnessMap4 = loadTexture( "textures/texture_sword/Metal007_2K_Metalness.jpg" );
			var metalnessMap5 = loadTexture( "textures/texture_shield/PaintedMetal004_2K_Metalness.jpg" );

            var aoMap1 = loadTexture( "textures/texture_axes/Metal032_2K_AO.jpg" );
            var aoMap2 = loadTexture( "textures/texture_axes/Metal034_2K_AO.jpg" );
			var aoMap3 = loadTexture( "textures/texture_axes/WoodSiding009_2K_AO.jpg" );
            var aoMap4 = loadTexture( "textures/texture_sword/Metal007_2K_AO.jpg" );
			var aoMap5 = loadTexture( "textures/texture_shield/PaintedMetal004_2K_AO.jpg" );
            
            var glowMap = loadTexture( "textures/glow3.png" );
            
            var noiseTexture = loadTexture( 'textures/cloud.png' );
	        //noiseTexture.wrapS = noiseTexture.wrapT = THREE.RepeatWrapping; 
            
            var loader = new THREE.CubeTextureLoader();
				loader.setPath( 'envMap/night meadow/' );

				var textureCube = loader.load( [
					'px.png', 'nx.png',
					'py.png', 'ny.png',
					'pz.png', 'nz.png'
				] );
				textureCube.minFilter = THREE.LinearMipMapLinearFilter;

			scene.background = textureCube;

            loader.setPath( 'envMap/night meadow irradiance/' );

            var irradianceMap=loader.load([
                    'px.png', 'nx.png',
					'py.png', 'ny.png',
					'pz.png', 'nz.png'
            ]);
            irradianceMap.minFilter = THREE.LinearMipMapLinearFilter;

            var oggetto = {
				model: 'Axe'
			}

            var raygodsS={
                ray:false,
                effects:0
            }

            var material = {
				texture1: 'MetalAxe',
                texture2: 'GoldAxe',
                texture3: 'WoodAxe',
                texture4: '',
                texture5: '',
            }
            
            var rotation={
                rotationX:0,
                rotationY:0,
                rotationZ:0
            }

            var scale={
                scaleX:1,
                scaleY:1,
                scaleZ:1
            }

            var emissive={
                red:22.7,
                green:1.0,
                blue:0.1
            }

            var textureParameters={
                normalScale: 0.0,
                nu:1.0,
                nd:1.0
            }

            var traslate={
                translateX:0,
                translateY:0,
                translateZ:0
            }

            var lightSettings={
                x:0,
                y:15,
                z:0,
                R:0.95,
                G:0.95,
                B:0.95,
                intensity:5.0
            }

            var backgroundMap={
                map:'Night Meadow'
            }

            var glass={
                uno:0,
                due:0,
                tre:0,
                quattro:1,
                cinque:0
            }

            var em={
                uno:0,
                due:0,
                tre:0,
                quattro:0,
                cinque:1
            }

            var objects=[];

			var uniforms1 = {
                    specularMap: { type: "t", value: specularMap1},
                    diffuseMap:	{ type: "t", value: diffuseMap1},
                    metalnessMap:	{ type: "t", value: metalnessMap1},
				    roughnessMap: { type: "t", value: roughness1},
					normalMap:	{ type: "t", value: normalMap1},
                    AOMap: {type: "t", value: aoMap1},
					normalScale: {type: "v2", value: new THREE.Vector2(1,1)},
					pointLightPosition:	{ type: "v3", value: new THREE.Vector3(lightSettings.x,lightSettings.y,lightSettings.z) },
					clight:	{ type: "v3", value: new THREE.Vector3(lightSettings.R,lightSettings.G,lightSettings.B) },
                    intensity: {type: "f", value: lightSettings.intensity},
                    textureRepeat: { type: "v2", value: new THREE.Vector2(1,1)},
                    envMap:	{ type: "t", value: textureCube},
                    glowMap:{type:"t",value:glowMap},
                    emissiveC:{type:'v3',value: new THREE.Vector3(emissive.red,emissive.green,emissive.blue)},
                    noiseTexture:{type:"t",value:noiseTexture},
		            time:{ type: "f", value: 1.0 },
                    animEn:{type:"f",value:0.0},
                    irradianceMap:{type:"t",value:irradianceMap}
                    };
            var uniforms2 = {
                    specularMap: { type: "t", value: specularMap2},
                    diffuseMap:	{ type: "t", value: diffuseMap2},
                    metalnessMap:	{ type: "t", value: metalnessMap2},
				    roughnessMap: { type: "t", value: roughness2},
					normalMap:	{ type: "t", value: normalMap2},
                    AOMap: {type: "t", value: aoMap2},
					normalScale: {type: "v2", value: new THREE.Vector2(1,1)},
					pointLightPosition:	{ type: "v3", value: new THREE.Vector3(lightSettings.x,lightSettings.y,lightSettings.z) },
					clight:	{ type: "v3", value: new THREE.Vector3(lightSettings.R,lightSettings.G,lightSettings.B) },
                    intensity: {type: "f", value: lightSettings.intensity},
                    textureRepeat: { type: "v2", value: new THREE.Vector2(1,1)},
                    envMap:	{ type: "t", value: textureCube},
                    glowMap:{type:"t",value:glowMap},
                    emissiveC:{type:'v3',value: new THREE.Vector3(emissive.red,emissive.green,emissive.blue)},
                    noiseTexture:{type:"t",value:noiseTexture},
		            time:{ type: "f", value: 1.0 },
                    animEn:{type:"f",value:0.0},
                    irradianceMap:{type:"t",value:irradianceMap}
                    };
            var uniforms3 = {
                    specularMap: { type: "t", value: specularMap3},
					diffuseMap:	{ type: "t", value: diffuseMap3},
					metalnessMap:	{ type: "t", value: metalnessMap3},
				    roughnessMap: { type: "t", value: roughness3},
					normalMap:	{ type: "t", value: normalMap3},
                    AOMap: {type: "t", value: aoMap3},
					normalScale: {type: "v2", value: new THREE.Vector2(1,1)},
					pointLightPosition:	{ type: "v3", value: new THREE.Vector3(lightSettings.x,lightSettings.y,lightSettings.z) },
					clight:	{ type: "v3", value: new THREE.Vector3(lightSettings.R,lightSettings.G,lightSettings.B) },
                    intensity: {type: "f", value: lightSettings.intensity},
                    textureRepeat: { type: "v2", value: new THREE.Vector2(1,1)},
                    envMap:	{ type: "t", value: textureCube},
                    glowMap:{type:"t",value:glowMap},
                    emissiveC:{type:'v3',value: new THREE.Vector3(emissive.red,emissive.green,emissive.blue)},
                    noiseTexture:{type:"t",value:noiseTexture},
		            time:{ type: "f", value: 1.0 },
                    animEn:{type:"f",value:0.0},
                    irradianceMap:{type:"t",value:irradianceMap}
					};
            var uniforms4 = {
                    specularMap: { type: "t", value: specularMap4},
					diffuseMap:	{ type: "t", value: diffuseMap4},
					metalnessMap:	{ type: "t", value: metalnessMap4},
				    roughnessMap: { type: "t", value: roughness4},
					normalMap:	{ type: "t", value: normalMap4},
                    AOMap: {type: "t", value: aoMap4},
					normalScale: {type: "v2", value: new THREE.Vector2(1,1)},
					pointLightPosition:	{ type: "v3", value: new THREE.Vector3(lightSettings.x,lightSettings.y,lightSettings.z) },
					clight:	{ type: "v3", value: new THREE.Vector3(lightSettings.R,lightSettings.G,lightSettings.B) },
                    intensity: {type: "f", value: lightSettings.intensity},
                    textureRepeat: { type: "v2", value: new THREE.Vector2(1,1)},
                    envMap:	{ type: "t", value: textureCube},
                    glowMap:{type:"t",value:glowMap},
                    emissiveC:{type:'v3',value: new THREE.Vector3(emissive.red,emissive.green,emissive.blue)},
                    noiseTexture:{type:"t",value:noiseTexture},
		            time:{ type: "f", value: 1.0 },
                    animEn:{type:"f",value:0.0},
                    irradianceMap:{type:"t",value:irradianceMap}
					};
            var uniforms5 = {
                    specularMap: { type: "t", value: specularMap5},
					diffuseMap:	{ type: "t", value: diffuseMap5},
					metalnessMap:	{ type: "t", value: metalnessMap5},
				    roughnessMap: { type: "t", value: roughness5},
					normalMap:	{ type: "t", value: normalMap5},
                    AOMap: {type: "t", value: aoMap5},
					normalScale: {type: "v2", value: new THREE.Vector2(1,1)},
					pointLightPosition:	{ type: "v3", value: new THREE.Vector3(lightSettings.x,lightSettings.y,lightSettings.z) },
					clight:	{ type: "v3", value: new THREE.Vector3(lightSettings.R,lightSettings.G,lightSettings.B) },
                    intensity: {type: "f", value: lightSettings.intensity},
                    textureRepeat: { type: "v2", value: new THREE.Vector2(1,1)},
                    envMap:	{ type: "t", value: textureCube},
                    glowMap:{type:"t",value:glowMap},
                    emissiveC:{type:'v3',value: new THREE.Vector3(emissive.red,emissive.green,emissive.blue)},
                    noiseTexture:{type:"t",value:noiseTexture},
		            time:{ type: "f", value: 1.0 },
                    animEn:{type:"f",value:0.0},
                    irradianceMap:{type:"t",value:irradianceMap}
					};

			vs = document.getElementById("vertex").textContent;
			fs = document.getElementById("fragment").textContent;
            fsIrr=document.getElementById("fragmentIrr").textContent;
            fsGlow=document.getElementById("fragmentGlow").textContent;
            vsCG=document.getElementById("vertexCustomGlow").textContent;
            fsCG=document.getElementById("fragmentCustomGlow").textContent;
            fsGlass=document.getElementById("fragmentGlass").textContent;

			var ourMaterial = [new THREE.ShaderMaterial({ uniforms: uniforms1, vertexShader: vs, fragmentShader: fs, side: THREE.DoubleSide }),
                                new THREE.ShaderMaterial({ uniforms: uniforms2, vertexShader: vs, fragmentShader: fs, side: THREE.DoubleSide }),
                                new THREE.ShaderMaterial({ uniforms: uniforms3, vertexShader: vs, fragmentShader: fs, side: THREE.DoubleSide }),
                                new THREE.ShaderMaterial({ uniforms: uniforms4, vertexShader: vs, fragmentShader: fs, side: THREE.DoubleSide }),
                                new THREE.ShaderMaterial({ uniforms: uniforms5, vertexShader: vs, fragmentShader: fs, side: THREE.DoubleSide })];
			ourMaterial.vertexTangents = true;
			ourMaterial.needsUpdate = true;

            var altMaterial = [new THREE.ShaderMaterial({ uniforms: uniforms1, vertexShader: vs, fragmentShader: fsIrr, side: THREE.DoubleSide }),
                                new THREE.ShaderMaterial({ uniforms: uniforms2, vertexShader: vs, fragmentShader: fsIrr, side: THREE.DoubleSide }),
                                new THREE.ShaderMaterial({ uniforms: uniforms3, vertexShader: vs, fragmentShader: fsIrr, side: THREE.DoubleSide }),
                                new THREE.ShaderMaterial({ uniforms: uniforms4, vertexShader: vs, fragmentShader: fsIrr, side: THREE.DoubleSide }),
                                new THREE.ShaderMaterial({ uniforms: uniforms5, vertexShader: vs, fragmentShader: fsIrr, side: THREE.DoubleSide })];
            altMaterial.vertexTangents = true;
			altMaterial.needsUpdate = true;

            var glassMaterial=[new THREE.ShaderMaterial({ uniforms: uniforms1, vertexShader: vs, fragmentShader: fsGlass, side: THREE.DoubleSide, transparent:true }),
                                new THREE.ShaderMaterial({ uniforms: uniforms2, vertexShader: vs, fragmentShader: fsGlass, side: THREE.DoubleSide, transparent:true }),
                                new THREE.ShaderMaterial({ uniforms: uniforms3, vertexShader: vs, fragmentShader: fsGlass, side: THREE.DoubleSide, transparent:true }),
                                new THREE.ShaderMaterial({ uniforms: uniforms4, vertexShader: vs, fragmentShader: fsGlass, side: THREE.DoubleSide, transparent:true }),
                                new THREE.ShaderMaterial({ uniforms: uniforms5, vertexShader: vs, fragmentShader: fsGlass, side: THREE.DoubleSide, transparent:true })
            ];
            glassMaterial.vertexTangents=true;
            glassMaterial.needsUpdate=true;

            var glowMaterial=[new THREE.ShaderMaterial({ uniforms: uniforms1, vertexShader: vs, fragmentShader: fsGlow, side: THREE.DoubleSide }),
                                new THREE.ShaderMaterial({ uniforms: uniforms2, vertexShader: vs, fragmentShader: fsGlow, side: THREE.DoubleSide }),
                                new THREE.ShaderMaterial({ uniforms: uniforms3, vertexShader: vs, fragmentShader: fsGlow, side: THREE.DoubleSide }),
                                new THREE.ShaderMaterial({ uniforms: uniforms4, vertexShader: vs, fragmentShader: fsGlow, side: THREE.DoubleSide }),
                                new THREE.ShaderMaterial({ uniforms: uniforms5, vertexShader: vs, fragmentShader: fsGlow, side: THREE.DoubleSide }),
            ];
            glowMaterial.vertexTangents=true;
            glowMaterial.needsUpdate=true;

            var customGlowMaterial=new THREE.ShaderMaterial({uniforms:{
                "c":   { type: "f", value: 1.25 },//soglia del dot products tra normale e view camera, influisce su quantità di flow visibile
			    "p":   { type: "f", value: 2.0 },//fattore che indica la potenza dell'effetto(più piccola è meglio)
			    glowColor: { type: "c", value: new THREE.Color(0xffff00) },
			    viewVector: { type: "v3", value: camera.position }},vertexShader:vsCG,fragmentShader:fsCG,side: THREE.FrontSide,
                blending: THREE.AdditiveBlending,//modalità blending additiva per gestire trasparenza materiale con altri elementi opachi
                transparent: true});
            customGlowMaterial.vertexTangents=true;
            customGlowMaterial.needsUpdate=true;
			
            //caricamento di default del primo modello (ascia)
			var loader = new THREE.GLTFLoader();
			loader.useIndices = true;
			loader.load( "models/axes5.glb", function ( model ) {
                    console.log(model);
                    model.scene.children[0].children[0].material=ourMaterial[0];
                    emMesh=model.scene.children[0].children[0];
                    model.scene.children[0].children[1].material=ourMaterial[1];
                    emMesh1=model.scene.children[0].children[1];
                    model.scene.children[0].children[2].material=ourMaterial[2];
                    emMesh2=model.scene.children[0].children[2];
                    THREE.BufferGeometryUtils.computeTangents(model.scene.children[0].children[0].geometry);
                    THREE.BufferGeometryUtils.computeTangents(model.scene.children[0].children[1].geometry);
                    THREE.BufferGeometryUtils.computeTangents(model.scene.children[0].children[2].geometry);
                    objects.push(emMesh);
                    objects.push(emMesh1);
                    objects.push(emMesh2);
                    obj.add(emMesh);
                    obj.add(emMesh1);
                    obj.add(emMesh2);
                    obj.scale.multiplyScalar(0.1);
                    scene.add(model.scene.children[0]);


				} );

            //definizione delle funzioni che caricano i 3 modelli 3d
            function loadAxes(){
                var loader = new THREE.GLTFLoader();
			    loader.useIndices = true;
				loader.load( "models/axes5.glb", function ( model ) {
                    console.log(model);
                    model.scene.children[0].children[0].material=ourMaterial[0];
                    emMesh=model.scene.children[0].children[0];
                    model.scene.children[0].children[1].material=ourMaterial[1];
                    emMesh1=model.scene.children[0].children[1];
                    model.scene.children[0].children[2].material=ourMaterial[2];
                    emMesh2=model.scene.children[0].children[2];
                    THREE.BufferGeometryUtils.computeTangents(model.scene.children[0].children[0].geometry);
                    THREE.BufferGeometryUtils.computeTangents(model.scene.children[0].children[1].geometry);
                    THREE.BufferGeometryUtils.computeTangents(model.scene.children[0].children[2].geometry);
                    objects.push(emMesh);
                    objects.push(emMesh1);
                    objects.push(emMesh2);
                    obj.add(emMesh);
                    obj.add(emMesh1);
                    obj.add(emMesh2);
                    obj.scale.y=0.1;
                    scene.add(model.scene.children[0]);

				} );
            }

            function loadSickle(){

                var loader = new THREE.GLTFLoader();
			    loader.useIndices = true;
				loader.load( "models/falce.glb", function ( model ) {
                    console.log(model);
                    model.scene.children[0].children[0].material=ourMaterial[0];
                    emMesh=model.scene.children[0].children[0];
                    model.scene.children[0].children[1].material=ourMaterial[1];
                    emMesh1=model.scene.children[0].children[1];
                    model.scene.children[0].children[2].material=ourMaterial[2];
                    emMesh2=model.scene.children[0].children[2];
                    model.scene.children[0].children[3].material=ourMaterial[3];
                    emMesh3=model.scene.children[0].children[3];
                    model.scene.children[0].children[4].material=ourMaterial[4];
                    emMesh4=model.scene.children[0].children[4];
                    THREE.BufferGeometryUtils.computeTangents(model.scene.children[0].children[0].geometry);
                    THREE.BufferGeometryUtils.computeTangents(model.scene.children[0].children[1].geometry);
                    THREE.BufferGeometryUtils.computeTangents(model.scene.children[0].children[2].geometry);
                    THREE.BufferGeometryUtils.computeTangents(model.scene.children[0].children[3].geometry);
                    THREE.BufferGeometryUtils.computeTangents(model.scene.children[0].children[4].geometry);
                    objects.push(emMesh);
                    objects.push(emMesh1);
                    objects.push(emMesh2);
                    objects.push(emMesh3);
                    objects.push(emMesh4);
                    obj.add(emMesh);
                    obj.add(emMesh1);
                    obj.add(emMesh2);
                    obj.add(emMesh3);
                    obj.add(emMesh4);
                    obj.scale.y=4.5;
                    scene.add(model.scene.children[0]);

				} );
            }

            function loadShield(){
                var loader = new THREE.GLTFLoader();
			    loader.useIndices = true;
				loader.load( "models/shield3.glb", function ( model ) {
                    console.log(model);
                    model.scene.children[0].children[0].material=ourMaterial[0];
                    emMesh=model.scene.children[0].children[0];
                    model.scene.children[0].children[1].material=ourMaterial[1];
                    emMesh1=model.scene.children[0].children[1];
                    model.scene.children[0].children[2].material=ourMaterial[2];
                    emMesh2=model.scene.children[0].children[2];
                    THREE.BufferGeometryUtils.computeTangents(model.scene.children[0].children[0].geometry);
                    THREE.BufferGeometryUtils.computeTangents(model.scene.children[0].children[1].geometry);
                    THREE.BufferGeometryUtils.computeTangents(model.scene.children[0].children[2].geometry);
                    objects.push(emMesh);
                    objects.push(emMesh1);
                    objects.push(emMesh2);
                    obj.add(emMesh);
                    obj.add(emMesh1);
                    obj.add(emMesh2);
                    obj.scale.y=0.1;
                    scene.add(model.scene.children[0]);

				} );
            }

            function loadSword(){
                var loader = new THREE.GLTFLoader();
			    loader.useIndices = true;
				loader.load( "models/sword.glb", function ( model ) {
                    console.log(model);
                    model.scene.children[0].children[0].material=ourMaterial[0];
                    emMesh=model.scene.children[0].children[0];
                    model.scene.children[0].children[1].material=ourMaterial[1];
                    emMesh1=model.scene.children[0].children[1];
                    model.scene.children[0].children[2].material=ourMaterial[2];
                    emMesh2=model.scene.children[0].children[2];
                    THREE.BufferGeometryUtils.computeTangents(model.scene.children[0].children[0].geometry);
                    THREE.BufferGeometryUtils.computeTangents(model.scene.children[0].children[1].geometry);
                    THREE.BufferGeometryUtils.computeTangents(model.scene.children[0].children[2].geometry);
                    objects.push(emMesh);
                    objects.push(emMesh1);
                    objects.push(emMesh2);
                    obj.add(emMesh);
                    obj.add(emMesh1);
                    obj.add(emMesh2);
                    obj.scale.y=0.1;
                    scene.add(model.scene.children[0]);
				} );
            }

            //definizione delle funzioni che caricano le diverse environment map
            function loadEnvMapNM(){
                var loader = new THREE.CubeTextureLoader();
				loader.setPath( 'envMap/night meadow/' );

				textureCube = loader.load( [
					'px.png', 'nx.png',
					'py.png', 'ny.png',
					'pz.png', 'nz.png'
				] );
				textureCube.minFilter = THREE.LinearMipMapLinearFilter;

			    scene.background = textureCube;

                loader.setPath( 'envMap/night meadow irradiance/' );

                var irradianceMap=loader.load([
                        'px.png', 'nx.png',
                        'py.png', 'ny.png',
                        'pz.png', 'nz.png'
                ]);
                irradianceMap.minFilter = THREE.LinearMipMapLinearFilter;
                uniforms1.irradianceMap.value=irradianceMap;
                uniforms2.irradianceMap.value=irradianceMap;
                uniforms3.irradianceMap.value=irradianceMap;
                uniforms4.irradianceMap.value=irradianceMap;
                uniforms5.irradianceMap.value=irradianceMap;
            }

            function loadEnvMapCG(){
                var loader = new THREE.CubeTextureLoader();
				loader.setPath( 'envMap/chinese garden/' );

				textureCube = loader.load( [
					'px.png', 'nx.png',
					'py.png', 'ny.png',
					'pz.png', 'nz.png'
				] );
				textureCube.minFilter = THREE.LinearMipMapLinearFilter;

			    scene.background = textureCube;

                loader.setPath( 'envMap/chinese garden irradiance/' );

                var irradianceMap=loader.load([
                        'px.png', 'nx.png',
                        'py.png', 'ny.png',
                        'pz.png', 'nz.png'
                ]);
                irradianceMap.minFilter = THREE.LinearMipMapLinearFilter;
                uniforms1.irradianceMap.value=irradianceMap;
                uniforms2.irradianceMap.value=irradianceMap;
                uniforms3.irradianceMap.value=irradianceMap;
                uniforms4.irradianceMap.value=irradianceMap;
                uniforms5.irradianceMap.value=irradianceMap;
            }

            function loadEnvMapE(){
                var loader = new THREE.CubeTextureLoader();
				loader.setPath( 'envMap/external/' );

				textureCube = loader.load( [
					'px.png', 'nx.png',
					'py.png', 'ny.png',
					'pz.png', 'nz.png'
				] );
				textureCube.minFilter = THREE.LinearMipMapLinearFilter;

			    scene.background = textureCube;

                loader.setPath( 'envMap/external irradiance/' );

                var irradianceMap=loader.load([
                        'px.png', 'nx.png',
                        'py.png', 'ny.png',
                        'pz.png', 'nz.png'
                ]);
                irradianceMap.minFilter = THREE.LinearMipMapLinearFilter;
                uniforms1.irradianceMap.value=irradianceMap;
                uniforms2.irradianceMap.value=irradianceMap;
                uniforms3.irradianceMap.value=irradianceMap;
                uniforms4.irradianceMap.value=irradianceMap;
                uniforms5.irradianceMap.value=irradianceMap;
            }

            function loadEnvMapI(){
                var loader = new THREE.CubeTextureLoader();
				loader.setPath( 'envMap/internal/' );

				textureCube = loader.load( [
					'px.png', 'nx.png',
					'py.png', 'ny.png',
					'pz.png', 'nz.png'
				] );
				textureCube.minFilter = THREE.LinearMipMapLinearFilter;

			    scene.background = textureCube;

                loader.setPath( 'envMap/internal irradiance/' );

                var irradianceMap=loader.load([
                        'px.png', 'nx.png',
                        'py.png', 'ny.png',
                        'pz.png', 'nz.png'
                ]);
                irradianceMap.minFilter = THREE.LinearMipMapLinearFilter;
                uniforms1.irradianceMap.value=irradianceMap;
                uniforms2.irradianceMap.value=irradianceMap;
                uniforms3.irradianceMap.value=irradianceMap;
                uniforms4.irradianceMap.value=irradianceMap;
                uniforms5.irradianceMap.value=irradianceMap;
            }

            function loadEnvMapNP(){
                var loader = new THREE.CubeTextureLoader();
				loader.setPath( 'envMap/night park/' );

				textureCube = loader.load( [
					'px.png', 'nx.png',
					'py.png', 'ny.png',
					'pz.png', 'nz.png'
				] );
				textureCube.minFilter = THREE.LinearMipMapLinearFilter;

			    scene.background = textureCube;

                loader.setPath( 'envMap/night park irradiance/' );

                var irradianceMap=loader.load([
                        'px.png', 'nx.png',
                        'py.png', 'ny.png',
                        'pz.png', 'nz.png'
                ]);
                irradianceMap.minFilter = THREE.LinearMipMapLinearFilter;
                uniforms1.irradianceMap.value=irradianceMap;
                uniforms2.irradianceMap.value=irradianceMap;
                uniforms3.irradianceMap.value=irradianceMap;
                uniforms4.irradianceMap.value=irradianceMap;
                uniforms5.irradianceMap.value=irradianceMap;
            }

            function loadEnvMapS(){
                var loader = new THREE.CubeTextureLoader();
				loader.setPath( 'envMap/studio/' );

				textureCube = loader.load( [
					'px.png', 'nx.png',
					'py.png', 'ny.png',
					'pz.png', 'nz.png'
				] );
				textureCube.minFilter = THREE.LinearMipMapLinearFilter;

			    scene.background = textureCube;

                loader.setPath( 'envMap/studio irradiance/' );

                var irradianceMap=loader.load([
                        'px.png', 'nx.png',
                        'py.png', 'ny.png',
                        'pz.png', 'nz.png'
                ]);
                irradianceMap.minFilter = THREE.LinearMipMapLinearFilter;
                uniforms1.irradianceMap.value=irradianceMap;
                uniforms2.irradianceMap.value=irradianceMap;
                uniforms3.irradianceMap.value=irradianceMap;
                uniforms4.irradianceMap.value=irradianceMap;
                uniforms5.irradianceMap.value=irradianceMap;
            }

			function loadTexture(file) {
					var texture = new THREE.TextureLoader().load( file , function ( texture ) {

						texture.minFilter = THREE.LinearMipMapLinearFilter;
						texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
						texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
    			  		texture.offset.set( 0, 0 );
						texture.needsUpdate = true;
						render();
					} )
					return texture;
            }

            //funzione che inizializza la scena
			function init() {

				renderer.autoClearColor=false;
                renderer.autoClearDepth= true;
                renderer.autoClearStencil= true;

				camera.position.set( 0, 0, 10 );
				scene.add( camera );

				document.body.appendChild( renderer.domElement );
				renderer.setPixelRatio( window.devicePixelRatio * 3.5 );
				renderer.setSize( window.innerWidth/2.0, window.innerHeight/2.0 );

				controls.minDistance = 1;
				controls.maxDistance = 100;
				controls.enablePan = false;
				controls.update();

				window.addEventListener( 'resize', onResize, false );

                
                composer = new THREE.EffectComposer( renderer);
                composer.addPass( new THREE.RenderPass( scene, camera ) );

                fxaa=new THREE.ShaderPass( fxaa );
                composer.addPass(fxaa);
                fxaa.renderToScreen=true;

			}

            //funzioni che gestiscono il funzionamento generale
			function onResize() {

				renderer.setSize( window.innerWidth/2.0, window.innerHeight/2.0 );
				camera.aspect = ( window.innerWidth / window.innerHeight );
				camera.updateProjectionMatrix();

			}

			function update() {
				requestAnimationFrame( update );
                var anim=document.getElementById("animated");
                var film=document.getElementById("film");
                if(anim.checked==true){
                    var delta = clock.getDelta();
                    uniforms1.time.value+=delta;
                    uniforms2.time.value-=delta;
                    uniforms3.time.value+=delta/2.0;
                    uniforms4.time.value-=delta/2.0;
                    uniforms5.time.value+=delta*5.0;
                }
                if(film.checked==true){
                    filmpass.uniforms.amount.value+=0.1;
                }
                if(copyMesh!=undefined){
                    copyMesh.material.uniforms.viewVector.value = 
		            new THREE.Vector3().subVectors( camera.position, copyMesh.position );//camera.position - copyMesh.position
                }
                if(copyMesh1!=undefined){
                    copyMesh1.material.uniforms.viewVector.value = 
		            new THREE.Vector3().subVectors( camera.position, copyMesh1.position );//camera.position - copyMesh1.position
                }
                if(copyMesh2!=undefined){
                    copyMesh2.material.uniforms.viewVector.value = 
		            new THREE.Vector3().subVectors( camera.position, copyMesh2.position );//camera.position - copyMesh2.position
                }
                if(copyMesh3!=undefined){
                    copyMesh3.material.uniforms.viewVector.value = 
		            new THREE.Vector3().subVectors( camera.position, copyMesh3.position );//camera.position - copyMesh3.position
                }
                if(copyMesh4!=undefined){
                    copyMesh4.material.uniforms.viewVector.value = 
		            new THREE.Vector3().subVectors( camera.position, copyMesh4.position );//camera.position - copyMesh4.position
                }
				render();
			}

			function render() {
                composer.render();
			}

			init();
			update();
			render();

        </script>
        <footer class="half" style="position: absolute;width:100%;bottom:0px;">
			<div class="container-fluid-padding" style="height: 202px;">
						<h5 id="text1">Compared to the ax, designed to cut down trees, the battle ax, designed to hit the opponent's arms or legs, has a lighter and more curved metal head.</h5>
                        <h5 id="text2">The weapon, depending on its size, could be wielded with one or two hands and was intended either to guarantee the possibility of fast and repeated attacks or powerful attacks, aimed at knocking down or weakening the opponent.</h5>
                        <h5 id="text3">The battle axes with a half-moon metal head, widespread in Europe during the Roman period, were usually made of wrought iron with a carbon steel edge or, typical of medieval axes, of pure steel.</h5>
                        <h5 id="text4">The wooden handle was reinforced with metal strips to ensure greater solidity in the event of an attack carried by the opponent under the ax head. Some models from the Renaissance period feature entirely metal handles.</h5>
                        <h1>
                            <h5 style="display: inline;">
                                Price:
                            </h5>
                            <b id="price" style="display: inline;">
                                50$
                            </b>
                            <button>Buy it!</button>
                        </h1>
            </div>
		</footer>
    </body>
</html>